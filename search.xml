<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Centos 内存信息]]></title>
    <url>%2F2018%2F07%2F23%2FCentos%20%E5%86%85%E5%AD%98%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[1 Free1.1 CentOS6及以前在CentOS6及以前的版本中，free命令输出是这样的： 123456$free -m total used free shared buffers cachedMem: 1002 769 233 0 62 421-/+ buffers/cache: 286 716Swap: 1153 0 1153 第一行： ​ 系统内存主要分为四部分：used(程序已使用内存)，free(空闲内存)，buffers(buffer cache)， cached(Page cache)。 ​ 系统总内存total = used + free； buffers和cached被算在used里，因此第一行系统已使用内存used = buffers + cached + 第二行系统已使用内存used。 ​ 由于buffers和cached在系统需要时可以被回收使用，因此系统可用内存 = free + buffers + cached； ​ shared为程序共享的内存空间，往往为0。 第二行： 正因为buffers和cached在系统需要时可以被回收使用，因此buffer和cached其实可以可以算作可用内存，因此： 系统可用内存，即第二行的free = 第一行的free + buffers + cached。 系统已使用内存，即第二行的used = total - 第二行free。 第三行： ​ swap内存交换空间使用情况。 1.2 CentOS7及以后 CentOS7及以后free命令的输出如下： 1234# free -m total used free shared buff/cache availableMem: 3440 213 2276 168 950 2778Swap: 0 0 0 buffer和cached被合成一组，加入了一个available，关于此available，文档上的说明如下： MemAvailable: An estimate of how much memory is available for starting new applications, without swapping. 即系统可用内存，之前说过由于buffer和cache可以在需要时被释放回收，系统可用内存即 free + buffer + cache，在CentOS 7之后这种说法并不准确，因为并不是所有的buffer/cache空间都可以被回收。 即available = free + buffer/cache - 不可被回收内存(共享内存段、tmpfs、ramfs等)。 因此在CentOS7之后，用户不需要去计算buffer/cache，即可以看到还有多少内存可用，更加简单直观。 1.3 buffer/cache相关介绍什么是buffer/cache？ buffer 和 cache 是两个在计算机技术中被用滥的名词，放在不通语境下会有不同的意义。在 Linux 的内存管理中，这里的 buffer 指 Linux 内存的： Buffer cache 。这里的 cache 指 Linux 内存中的： Page cache 。翻译成中文可以叫做缓冲区缓存和页面缓存。在历史上，它们一个（ buffer ）被用来当成对 io 设备写的缓存，而另一个（ cache ）被用来当作对 io 设备的读缓存，这里的 io 设备，主要指的是块设备文件和文件系统上的普通文件。但是现在，它们的意义已经不一样了。在当前的内核中， page cache 顾名思义就是针对内存页的缓存，说白了就是，如果有内存是以 page 进行分配管理的，都可以使用 page cache 作为其缓存来管理使用。当然，不是所有的内存都是以页（ page ）进行管理的，也有很多是针对块（ block ）进行管理的，这部分内存使用如果要用到 cache 功能，则都集中到 buffer cache 中来使用。（从这个角度出发，是不是 buffer cache 改名叫做 block cache 更好？）然而，也不是所有块（ block ）都有固定长度，系统上块的长度主要是根据所使用的块设备决定的，而页长度在 X86 上无论是 32 位还是 64 位都是 4k 。 明白了这两套缓存系统的区别，就可以理解它们究竟都可以用来做什么了。 什么是 page cache Page cache 主要用来作为文件系统上的文件数据的缓存来用，尤其是针对当进程对文件有 read ／ write 操作的时候。如果你仔细想想的话，作为可以映射文件到内存的系统调用： mmap 是不是很自然的也应该用到 page cache ？在当前的系统实现里， page cache 也被作为其它文件类型的缓存设备来用，所以事实上 page cache 也负责了大部分的块设备文件的缓存工作。 什么是 buffer cache Buffer cache 则主要是设计用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用。这意味着某些对块的操作会使用 buffer cache 进行缓存，比如我们在格式化文件系统的时候。一般情况下两个缓存系统是一起配合使用的，比如当我们对一个文件进行写操作的时候， page cache 的内容会被改变，而 buffer cache 则可以用来将 page 标记为不同的缓冲区，并记录是哪一个缓冲区被修改了。这样，内核在后续执行脏数据的回写（ writeback ）时，就不用将整个 page 写回，而只需要写回修改的部分即可。 如何回收 cache ？ Linux 内核会在内存将要耗尽的时候，触发内存回收的工作，以便释放出内存给急需内存的进程使用。一般情况下，这个操作中主要的内存释放都来自于对 buffer ／ cache 的释放。尤其是被使用更多的 cache 空间。既然它主要用来做缓存，只是在内存够用的时候加快进程对文件的读写速度，那么在内存压力较大的情况下，当然有必要清空释放 cache ，作为 free 空间分给相关进程使用。所以一般情况下，我们认为 buffer/cache 空间可以被释放，这个理解是正确的。 但是这种清缓存的工作也并不是没有成本。理解 cache 是干什么的就可以明白清缓存必须保证 cache 中的数据跟对应文件中的数据一致，才能对 cache 进行释放。所以伴随着 cache 清除的行为的，一般都是系统 IO 飙高。因为内核要对比 cache 中的数据和对应硬盘文件上的数据是否一致，如果不一致需要写回，之后才能回收。 在系统中除了内存将被耗尽的时候可以清缓存以外，我们还可以使用下面这个文件来人工触发缓存清除的操作： 12[root@tencent64 ~]# cat /proc/sys/vm/drop_caches 1 方法是： 1echo 1 &gt; /proc/sys/vm/drop_caches 当然，这个文件可以设置的值分别为 1 、 2 、 3 。它们所表示的含义为： echo 1 &gt; /proc/sys/vm/drop_caches:表示清除 pagecache 。 echo 2 &gt; /proc/sys/vm/drop_caches:表示清除回收 slab 分配器中的对象（包括目录项缓存和 inode 缓存）。 slab 分配器是内核中管理内存的一种机制，其中很多缓存数据实现都是用的 pagecache 。 echo 3 &gt; /proc/sys/vm/drop_caches:表示清除 pagecache 和 slab 分配器中的缓存对象。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记-staticmethod、classmethod]]></title>
    <url>%2F2018%2F07%2F14%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-staticmethod%E3%80%81classmethod%2F</url>
    <content type="text"><![CDATA[网上看到的 写的很清晰之后再整理 1234567891011121314151617181920212223# 静态函数，类函数，成员函数 # 静态函数(@staticmethod): 即静态方法,主要处理与这个类的逻辑关联, 如验证数据; # 类函数(@classmethod):即类方法, 更关注于从类中调用方法, 而不是在实例中调用方法, 如构造重载; # 成员函数: 实例的方法, 只能通过实例进行调用; class Person: grade=1 def __init__(self,name): self.name = name def sayHi(self):#加 self 区别于普通函数 print 'Hello, your name is?',self.name # 声明静态，去掉则编译报错;还有静态方法不能访问类变量和实例变量 # 好处：不需要定义实例即可使用这个方法。另外，多个实例共享此静态方法。 @staticmethod def sayName():#使用了静态方法，则不能再使用 self print "my name is king"#,grade,#self.name # 类方法：一个类方法就可以通过类或它的实例来调用的方法, # 不管你是用类来调用这个方法还是类实例调用这个方法,该方法的第一个参数总是定义该方法的类对象。 @classmethod def classMethod(cls): print("class method") 顺便提一下类属性和实例属性： 类属性可用于为实例属性提供默认值。 类属性就是类中不加self的属性： 12345678910class Vector2d: typecode = 'd' def __init__(self, x, y): self.__x = float(x) self.__y = float(y) def __bytes__(self): return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self))) 123456789101112131415161718Vector2d.typecodeOut[11]: 'd' # 创建实例时，类属性会被当成实例属性并为实例属性提供默认值v1 = Vector2d(1.1, 2.2)dumpd = bytes(v1)dumpdOut[14]: b'd\x9a\x99\x99\x99\x99\x99\xf1?\x9a\x99\x99\x99\x99\x99\x01@' # 修改实例属性v1.typecode = 'f'dumpf = bytes(v1)dumpfOut[18]: b'f\xcd\xcc\x8c?\xcd\xcc\x0c@' # 类属性没有变Vector2d.typecodeOut[19]: 'd' 这种类型可以直接通过类来访问类属性； 创建实例时，类属性会被当成实例属性并为实例属性提供默认值。 所以说添加方法时也可以使用self.typecode来获取实例属性。 如果想修改类属性的值，必须直接在类上修改，不能通过实例修改。 1Vector2d.typecode = 'f' 有种修改方法更符合Python风格，而且效果更持久，也更有针对性。类属性是公开的，因此会被子类继承，于是经常会创建一个子类，只用于定制类的数据属性。 Django基于类的视图就大量使用了这个技术。 123from vector2d_v1 import Vector2dclass ShortVector2d(Vector2d): typecode = 'f']]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记-time模块]]></title>
    <url>%2F2018%2F07%2F13%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-time%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[在Python中，与时间处理有关的模块包括：time，datetime以及calendar。 Time模块-时间获取和转换一些术语和约定的解释 UTC（Coordinated Universal Time，世界协调时 ），也叫格林威治天文时间，是世界标准时间。在中国为UTC+8 DST（Daylight Saving Time ），即夏令时，是一种为节约能源而人为规定地方时间的制度，一般在天亮早的夏季人为将时间提前一小时。在中国1992年已经停止 一些实时函数的计算精度可能低于它们建议的值或参数，例如在大部分Unix系统，时钟一秒钟”滴答“50~100次 两种表现形式时间戳（timestamp）： 通常来说，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量（time.gmtime(0)），此模块中的函数无法处理1970纪元年以前的日期和时间或太遥远的未来（处理极限取决于C函数库，对于32位的系统来说是2038年） 时间元组（time.struct_time）： gmtime()，localtime()和strptime()以时间元组（struct_time）的形式返回。 索引值（Index） 属性（Attribute） 值（Values） 0 tm_year（年） （例如：2015） 1 tm_mon（月） 1 ~ 12 2 tm_mday（日） 1 ~ 31 3 tm_hour（时） 0 ~ 23 4 tm_min（分） 0 ~ 59 5 tm_sec（秒） 0 ~ 61（见下方注1） 6 tm_wday（星期几） 0 ~ 6（0 表示星期一） 7 tm_yday（一年中的第几天） 1 ~ 366 8 tm_isdst（是否为夏令时） 0， 1， -1（-1 代表夏令时） 注1：60 代表闰秒，61 是基于历史原因保留。 属性timezonetime.timezone 属性返回当地时间与标准UTC时间的误差，以秒计 （美洲 &gt;0；大部分欧洲，亚洲，非洲 &lt;= 0 1234&gt;&gt;&gt; time.timezone-28800&gt;&gt;&gt; -8*60*60-28800 altzonetime.altzone属性返回当地夏令时时间与标准UTC时间的误差，以秒计。 1234&gt;&gt;&gt; time.altzone-32400&gt;&gt;&gt; -9*60*60-32400 daylight 当地时间是否反映夏令时，默认为0 12&gt;&gt;&gt; time.daylight0 time.tznametime.tzname属性包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。 (标准时区名称,夏令时时区名称的元组) 12&gt;&gt;&gt; time.tzname('ÖÐ¹ú±ê×¼Ê±¼ä', 'ÖÐ¹úÏÄÁîÊ±') 函数timetime() 返回当前时间的时间戳（1970纪元年后经过的浮点秒数） 12&gt;&gt;&gt; time.time()1531461304.5539289 asctime asctime(…) asctime([tuple]) -&gt; string 接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2015”（2015年12月11日 周二 18时07分14秒）的 24 个字符的字符串。 12345&gt;&gt;&gt; t = time.localtime()&gt;&gt;&gt; ttime.struct_time(tm_year=2018, tm_mon=7, tm_mday=13, tm_hour=13, tm_min=38, tm_sec=44, tm_wday=4, tm_yday=194, tm_isdst=0)&gt;&gt;&gt; time.asctime(t)'Fri Jul 13 13:38:44 2018' clock clock(…) clock() -&gt; floating point number 用以浮点数计算的秒数返回当前的 CPU 时间。用来衡量不同程序的耗时，比 time.time() 更有用。 Python 3.3 以后不被推荐，由于该方法依赖操作系统，建议使用 perf_counter() 或 process_time() 代替（一个返回系统运行时间，一个返回进程运行时间，请按照实际需求选择） 在不同的系统上含义不同。在UNIX系统上，它返回的是“进程时间”，它是用秒表示的浮点数（时间戳）。而在Windows中，第一次调用，返回的是进程运行的实际时间。而第二次之后的调用是自第一次调用以后到现在的运行时间。（实际上是以WIN32上QueryPerformanceCounter()为基础，它比毫秒表示更为精确） 12345678910# 在Windows中，第一次调用，返回的是进程运行的实际时间。&gt;&gt;&gt; print('clock_1: %s' % time.clock() )clock_1: 4.276543543552533e-07# 第二次之后的调用是自第一次调用以后到现在的运行时间。&gt;&gt;&gt; print('clock_1: %s' % time.clock() )clock_1: 2.2088326019731115&gt;&gt;&gt; print('clock_2: %s' % time.clock() )clock_2: 8.735795567533678&gt;&gt;&gt; print('clock_3: %s' % time.clock() )clock_3: 13.871665204801532 ctime ctime(…) ctime(seconds) -&gt; string 把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。如果参数未给或者为None的时候，将会默认time.time()即当前时间戳为参数。它的作用相当于time.asctime(time.localtime(secs))。 123456&gt;&gt;&gt; time.ctime()'Fri Jul 13 14:36:18 2018'&gt;&gt;&gt; time.time()1531463798.9535468&gt;&gt;&gt; time.ctime(1531463798.9535468)'Fri Jul 13 14:36:38 2018' localtime localtime(…) localtime([seconds]) -&gt; (tm_year,tm_mon,tm_mday,tm_hour,tm_min, tm_sec,tm_wday,tm_yday,tm_isdst) 将一个时间戳转换为当前时区的struct_time。secs参数未提供，则以当前时间为准。 123456&gt;&gt;&gt; time.localtime()time.struct_time(tm_year=2018, tm_mon=7, tm_mday=13, tm_hour=14, tm_min=45, tm_sec=41, tm_wday=4, tm_yday=194, tm_isdst=0)&gt;&gt;&gt; time.time()1531464356.65697&gt;&gt;&gt; time.localtime(1531464356.65697)time.struct_time(tm_year=2018, tm_mon=7, tm_mday=13, tm_hour=14, tm_min=45, tm_sec=56, tm_wday=4, tm_yday=194, tm_isdst=0) gmtime gmtime(…) gmtime([seconds]) -&gt; (tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec, tm_wday, tm_yday, tm_isdst) 和localtime()方法类似，gmtime()方法是将一个时间戳转换为UTC时区（0时区）的struct_time。 12&gt;&gt;&gt; time.gmtime()time.struct_time(tm_year=2018, tm_mon=7, tm_mday=13, tm_hour=6, tm_min=47, tm_sec=35, tm_wday=4, tm_yday=194, tm_isdst=0) mktime mktime(…) mktime(tuple) -&gt; floating point number 将一个struct_time转化为时间戳。 12&gt;&gt;&gt; time.mktime(time.localtime())1531464557.0 perf_counter perf_counter(…) perf_counter() -&gt; float 返回计时器的精准时间（系统的运行时间），包含整个系统的睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。 123456&gt;&gt;&gt; t0 = time.perf_counter()&gt;&gt;&gt; t01420.9757357472427&gt;&gt;&gt; t1 = time.perf_counter()&gt;&gt;&gt; t1 - t023.103979024409227 process_time(未理解) process_time(…) process_time() -&gt; float 返回当前进程执行 CPU 的时间总和，不包含睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。 12&gt;&gt;&gt; time.process_time()0.125 sleep sleep(…) sleep(seconds) 线程推迟指定的时间运行，单位为秒。 1sleep(2) strfimestrftime(…) strftime(format[, tuple]) -&gt; string 把一个代表时间的元组或者struct_time（如由time.localtime()和time.gmtime()返回）转化为格式化的时间字符串。如果t未指定，将传入time.localtime()。如果元组中任何一个元素越界，ValueError的错误将会被抛出。 format 格式如下： 格式 含义 备注 %a 本地（locale）简化星期名称 %A 本地完整星期名称 %b 本地简化月份名称 %B 本地完整月份名称 %c 本地相应的日期和时间表示 %d 一个月中的第几天（01 - 31） %H 一天中的第几个小时（24 小时制，00 - 23） %l 一天中的第几个小时（12 小时制，01 - 12） %j 一年中的第几天（001 - 366） %m 月份（01 - 12） %M 分钟数（00 - 59） %p 本地 am 或者 pm 的相应符 注1 %S 秒（01 - 61） 注2 %U 一年中的星期数（00 - 53 星期天是一个星期的开始）第一个星期天之前的所有天数都放在第 0 周 注3 %w 一个星期中的第几天（0 - 6，0 是星期天） 注3 %W 和 %U 基本相同，不同的是 %W 以星期一为一个星期的开始 %x 本地相应日期 %X 本地相应时间 %y 去掉世纪的年份（00 - 99） %Y 完整的年份 %z 用 +HHMM 或 -HHMM 表示距离格林威治的时区偏移（H 代表十进制的小时数，M 代表十进制的分钟数） %Z 时区的名字（如果不存在为空字符） %% %号本身 注1：“%p”只有与“%I”配合使用才有效果。 注2：60 代表闰秒，61 是基于历史原因保留。 注3：当使用 strptime() 函数时，只有当在这年中的周数和天数被确定的时候 %U 和 %W 才会被计算。 12&gt;&gt;&gt; time.strftime('%Y-%m-%d %X')'2018-07-13 15:06:39' strptime strptime(…) strptime(string, format) -&gt; struct_time 把一个格式化时间字符串转化为 struct_time。实际上它和 strftime() 是逆操作。 123456&gt;&gt;&gt; time_now = time.strftime('%y-%m-%d %X') &gt;&gt;&gt; time_now '18-07-13 15:09:04' &gt;&gt;&gt; time.strptime(time_now, '%y-%m-%d %X') time.struct_time(tm_year=2018, tm_mon=7, tm_mday=13, tm_hour=15, tm_min=9, tm_sec=4, tm_wday=4, tm_yday=194, tm_isdst=-1) 总结根据之前描述，在Python中共有三种表达方式： timestamp tuple或者struct_time 格式化字符串。它们之间的转化如图所示：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记-函数内省]]></title>
    <url>%2F2018%2F07%2F13%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E5%86%85%E7%9C%81%2F</url>
    <content type="text"><![CDATA[学习《流畅的Python时》一等函数的函数内省时，有一些疑问： 什么是函数内省？ 函数内省有什么作用？ 书上没有涉及内省的概念，所以在网上查阅了一下资料来记录一下函数内省。 这篇笔记抄录于《Python自省指南》，由于这篇文章使用的是Python 2，我用Python 3再抄录一遍。 以及后面有我自己的补充，主要是加上书上的内容以及自己的理解。 什么是自省 在日常生活中，自省（introspection）是一种自我检查行为。自省是指对某人自身思想、情绪、动机和行为的检查。伟大的哲学家苏格拉底将生命中的大部分时间用于自我检查，并鼓励他的雅典朋友们也这样做。他甚至对自己作出了这样的要求：“未经自省的生命不值得存在。” 在计算机编程中，自省是指这种能力：检查某些事物以确定它是什么，它知道什么以及它能做什么。自省向程序员提供了极大的灵活性和控制力。一旦您使用了支持自省的编程预言，就会产生类似这样的感觉：“未经检查的对象不值得实例化”。 本文介绍了 Python 编程语言的自省能力。整个 Python 语言对自省提供了深入而广泛的支持。实际上，很难想象假如 Python 语言没有其自省特性是什么样子。在读完本文时，您应该能够非常轻松地洞察到自己 Python 对象的“灵魂”。 自省和反射 在网上有很多资料把自省和反射理解为一个概念，也有理解为不同概念的，在此讨论一下。 自省在wiki上的解释：在计算机科学中，内省是指计算机程序在运行时（Run time）检查对象（Object）类型的一种能力，通常也可以称作运行时类型检查。 不应该将内省和反射混淆。相对于内省，反射更进一步，是指计算机程序在运行时（Run time）可以访问、检测和修改它本身状态或行为的一种能力。 搜索自省和反射的区别，大部分都是讲java的，而python几乎都把自省和反射理解为一个概念。 有一个博客写到——我感 反射与自省其实是一回事 只是在JAVA中把自省说成反射，在PYTHON中把反射说成自省。 我也是这么觉得，所以目前姑且先把自省和反射理解为一个概念。以后有新的想法再来解释。 在深入研究更高级的技术之前，我们尽可能用最普通的方式来研究 Python 自省。有些读者甚至可能会争论说：我们开始时所讨论的特性不应称之为“自省”。我们必须承认，它们是否属于自省的范畴还有待讨论。但从本节的意图出发，我们所关心的只是找出有趣问题的答案。 现在让我们以交互方式使用 Python 来开始研究。这是前面已经在使用的一种方式。 联机帮助在交互模式下，用 help 向 Python 请求帮助。 1234567891011121314151617&gt;&gt;&gt; help()Welcome to Python 3.6&apos;s help utility!If this is your first time using Python, you should definitely check outthe tutorial on the Internet at https://docs.python.org/3.6/tutorial/.Enter the name of any module, keyword, or topic to get help on writingPython programs and using Python modules. To quit this help utility andreturn to the interpreter, just type &quot;quit&quot;.To get a list of available modules, keywords, symbols, or topics, type&quot;modules&quot;, &quot;keywords&quot;, &quot;symbols&quot;, or &quot;topics&quot;. Each module also comeswith a one-line summary of what it does; to list the modules whose nameor summary contain a given string such as &quot;spam&quot;, type &quot;modules spam&quot;.help&gt; 这时候就进入了联机帮助状态，根据提示输入keywords： 12345678910111213help&gt; keywordsHere is a list of the Python keywords. Enter any keyword to get more help.False def if raiseNone del import returnTrue elif in tryand else is whileas except lambda withassert finally nonlocal yieldbreak for notclass from orcontinue global pass 现在显示出了Python关键词的列表。按照说明我们继续输入关键字获取关键字的相关文档。 12345678910111213141516171819202122232425262728293031323334353637help&gt; in Membership test operations ************************** The operators &quot;in&quot; and &quot;not in&quot; test for membership. &quot;x in s&quot; evaluates to &quot;True&quot; if *x* is a member of *s*, and &quot;False&quot; otherwise. &quot;x not in s&quot; returns the negation of &quot;x in s&quot;. All built-in sequences and set types support this as well as dictionary, for which &quot;in&quot; tests whether the dictionary has a given key. For container types such as list, tuple, set, frozenset, dict, or collections.deque, the expression &quot;x in y&quot; is equivalent to &quot;any(x is e or x == e for e in y)&quot;. For the string and bytes types, &quot;x in y&quot; is &quot;True&quot; if and only if *x* is a substring of *y*. An equivalent test is &quot;y.find(x) != -1&quot;. Empty strings are always considered to be a substring of any other string, so &quot;&quot;&quot; in &quot;abc&quot;&quot; will return &quot;True&quot;. For user-defined classes which define the &quot;__contains__()&quot; method, &quot;x in y&quot; returns &quot;True&quot; if &quot;y.__contains__(x)&quot; returns a true value, and &quot;False&quot; otherwise. For user-defined classes which do not define &quot;__contains__()&quot; but do define &quot;__iter__()&quot;, &quot;x in y&quot; is &quot;True&quot; if some value &quot;z&quot; with &quot;x == z&quot; is produced while iterating over &quot;y&quot;. If an exception is raised during the iteration, it is as if &quot;in&quot; raised that exception. Lastly, the old-style iteration protocol is tried: if a class defines &quot;__getitem__()&quot;, &quot;x in y&quot; is &quot;True&quot; if and only if there is a non- negative integer index *i* such that &quot;x == y[i]&quot;, and all lower integer indices do not raise &quot;IndexError&quot; exception. (If any other exception is raised, it is as if &quot;in&quot; raised that exception). The operator &quot;not in&quot; is defined to have the inverse true value of &quot;in&quot;. Related help topics: SEQUENCEMETHODS 正如您从这个示例可以看到的，Python 的联机帮助实用程序会显示关于各种主题或特定对象的信息。帮助实用程序很有用，并确实利用了 Python 的自省能力。但仅仅使用帮助不会揭示帮助是如何获得其信息的。而且，因为本文的目的是揭示 Python 自省的所有秘密，所以我们必须迅速地跳出对帮助实用程序的讨论。 最后让我们来获得一个可用模块的列表。 模块只是包含 Python 代码的文本文件，其名称后缀是 .py 。如果在 Python 提示符下输入help(&#39;modules&#39;) ，或在 help 提示符下输入 modules ，则会看到一长列可用模块，类似于下面所示的部分列表。自己尝试它以观察您的系统中有哪些可用模块，并了解为什么会认为 Python 是“自带电池”的。 就是说 Python 在被安装时，就带了很多模块，这些模块是你以后开发中会用到的，比喻成电池，好比开发的助力工具），或者说是 Python 一被安装，就已经包含有的模块，不用我们费力再安装了。 1234567891011121314help&gt; modulesPlease wait a moment while I gather a list of all available modules...D:\Microsoft Visual Studio\Shared\Python36_64\lib\site-packages\IPython\kernel\__init__.py:13: ShimWarning: The `IPython.kernel` package has been deprecated since IPython 4.0.You should import from ipykernel or jupyter_client instead. &quot;You should import from ipykernel or jupyter_client instead.&quot;, ShimWarning)IPython asynchat idna sched__future__ asyncio imaplib secrets_ast asyncore imghdr select...ast idlelib runpyEnter any module name to get more help. Or, type &quot;modules spam&quot; to searchfor modules whose name or summary contain the string &quot;spam&quot;. dir()函数尽管查找和导入模块相对容易，但要记住每个模块包含什么却不是这么简单。你或许并不希望总是必须查看源代码来找出答案。幸运的是，Python 提供了一种方法，可以使用内置的 dir() 函数来检查模块（以及其它对象）的内容。 其实，这个东西我们已经一直在使用。 dir() 函数可能是 Python 自省机制中最著名的部分了。它返回传递给它的任何对象的属性名称经过排序的列表。如果不指定对象，则 dir() 返回当前作用域中（理解为某个范围）的名称。让我们将 dir() 函数应用于 keyword 模块，并观察它揭示了什么： 123&gt;&gt;&gt; import keyword&gt;&gt;&gt; dir(keyword)['__all__', '__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'iskeyword', 'kwlist', 'main'] 如果不带任何参数，则 dir() 返回当前作用域中的名称。请注意，因为我们先前导入了 keyword ，所以它们出现在列表中。导入模块将把该模块的名称添加到当前作用域： 12&gt;&gt;&gt; dir()['__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'keyword'] dir() 函数是内置函数，这意味着我们不必为了使用该函数而导入模块。不必做任何操作，Python 就可识别内置函数。 再观察，看到调用 dir() 后返回了这个名称 __builtins__ 。也许此处有连接。让我们在 Python 提示符下输入名称 __builtins__ ，并观察 Python 是否会告诉我们关于它的任何有趣的事情： 12&gt;&gt;&gt; __builtins__&lt;module '__builtin__' (built-in)&gt; 因此 __builtins__ 看起来象是当前作用域中绑定到名为 __builtin__ 的模块对象的名称。（因为模块不是只有多个单一值的简单对象，所以 Python 改在尖括号中显示关于模块的信息。） 注：如果您在磁盘上寻找 __builtin__.py 文件，将空手而归。这个特殊的模块对象是 Python 解释器凭空创建的，因为它包含着解释器始终可用的项。尽管看不到物理文件，但我们仍可以将 dir() 函数应用于这个对象，以观察所有内置函数、错误对象以及它所包含的几个杂项属性。 12&gt;&gt;&gt; dir(__builtins__)['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip'] dir() 函数适用于所有对象类型，包括字符串、整数、列表、元组、字典、函数、定制类、类实例和类方法。 例如将 dir() 应用于字符串对象，如您所见，即使简单的 Python 字符串也有许多属性 ： 12&gt;&gt;&gt; dir("This is a str.")['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] 我们来看一下其他的对象类型： 12&gt;&gt;&gt; dir(43)['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'numerator', 'real', 'to_bytes'] 12&gt;&gt;&gt; dir(&#123;&#125;)['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'] 12&gt;&gt;&gt; dir(set)['__and__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__iand__', '__init__', '__init_subclass__', '__ior__', '__isub__', '__iter__', '__ixor__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__or__', '__rand__', '__reduce__', '__reduce_ex__', '__repr__', '__ror__', '__rsub__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__xor__', 'add', 'clear', 'copy', 'difference', 'difference_update', 'discard', 'intersection', 'intersection_update', 'isdisjoint', 'issubset', 'issuperset', 'pop', 'remove', 'symmetric_difference', 'symmetric_difference_update', 'union', 'update'] 12&gt;&gt;&gt; dir(list)['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'] 通过dir()函数获取对象的属性以及方法，我们就可以随时的了解我们创建的对象包含了什么，以及可以做些什么。 文档字符串在许多 dir() 示例中，您可能会注意到的一个属性是 __doc__ 属性。这个属性是一个字符串，它包含了描述对象的注释。Python 称之为文档字符串或 docstring 。 如果模块、类、方法或函数定义的第一条语句是字符串，那么该字符串会作为对象的 __doc__ 属性与该对象关联起来。例如，看一下 str 类型对象的文档字符串。因为文档字符串通常包含嵌入的换行 \n ，我们将使用 Python 的 print 语句，以便输出更易于阅读： 1234567891011&gt;&gt;&gt; print(str.__doc__)str(object='') -&gt; strstr(bytes_or_buffer[, encoding[, errors]]) -&gt; strCreate a new string object from the given object. If encoding orerrors is specified, then the object must expose a data bufferthat will be decoded using the given encoding and error handler.Otherwise, returns the result of object.__str__() (if defined)or repr(object).encoding defaults to sys.getdefaultencoding().errors defaults to 'strict'. 利用自省检查 Python 对象前面已经好几次提到了“对象（object）”这个词，但一直没有真正定义它。编程环境中的对象很像。现实世界中的对象。实际的对象有一定的形状、大小、重量和其它特征。实际的对象还能够对其环境进行响应、与其它对象交互或执行任务。计算机中的对象试图模拟我们身边现实世界中的对象，包括象文档、日程表和业务过程这样的抽象对象。 其实，我总觉得把 object 翻译成对象，让人感觉很没有具象的感觉，因为在汉语里面，对象是一个很笼统的词汇。另外一种翻译，流行于台湾，把它称为“物件”，倒是挺不错的理解。当然，名词就不纠缠了，关键是理解内涵。关于面向对象编程，可以阅读维基百科的介绍——面向对象程序设计——先了解大概。 类似于实际的对象，几个计算机对象可能共享共同的特征，同时保持它们自己相对较小的变异特征。想一想您在书店中看到的书籍。书籍的每个物理副本都可能有污迹、几张破损的书页或唯一的标识号。尽管每本书都是唯一的对象，但都拥有相同标题的每本书都只是原始模板的实例，并保留了原始模板的大多数特征。 对于面向对象的类和类实例也是如此。例如，可以看到每个 Python 子符串都被赋予了一些属性， dir() 函数揭示了这些属性。 于是在计算机术语中，对象是拥有标识和值的事物，属于特定类型、具有特定特征和以特定方式执行操作。 并且，对象从一个或多个父类继承了它们的许多属性。除了关键字和特殊符号（象运算符，如 + 、 - 、 * 、 ** 、 / 、 % 、 &lt; 、 &gt; 等）外，Python 中的所有东西都是对象。Python 具有一组丰富的对象类型：字符串、整数、浮点、列表、元组、字典、函数、类、类实例、模块、文件等。 当您有一个任意的对象（也许是一个作为参数传递给函数的对象）时，可能希望知道一些关于该对象的情况。如希望 Python 告诉我们： 对象的名称是什么？ 这是哪种类型的对象？ 对象知道些什么？ 对象能做些什么？ 对象的父对象是谁？ 名称并非所有对象都有名称，但那些有名称的对象都将名称存储在其 __name__ 属性中。注：名称是从对象而不是引用该对象的变量中派生的。 1234567891011121314&gt;&gt;&gt; l = list# dir(l)和dir(list)结果相同&gt;&gt;&gt; dir(l)['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']&gt;&gt;&gt; dir(list)['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']&gt;&gt;&gt; l.__name__ 'list'&gt;&gt;&gt; list.__name__'list'# 我之前讲过__name__的用法&gt;&gt;&gt; __name__ #这是不一样的'__main__' 模块拥有名称，Python 解释器本身被认为是顶级模块或主模块。当以交互的方式运行 Python 时，局部 __name__ 变量被赋予值 &#39;__main__&#39; 。同样地，当从命令行执行 Python 模块，而不是将其导入另一个模块时，其 __name__ 属性被赋予值 &#39;__main__&#39; ，而不是该模块的实际名称。这样，模块可以查看其自身的 __name__ 值来自行确定它们自己正被如何使用，是作为另一个程序的支持，还是作为从命令行执行的主应用程序。因此，下面这条惯用的语句在 Python 模块中是很常见的： 12345678if __name__ == '__main__': # Do something appropriate here, like calling a # main() function defined elsewhere in this module. main()else: # Do nothing. This module has been imported by another # module that wants to make use of the functions, # classes and other useful bits it has defined. 类型type() 函数有助于我们确定对象是字符串还是整数，或是其它类型的对象。它通过返回类型对象来做到这一点。（其实就相当于访问对象__class__属性，个人理解） 12345678910111213141516&gt;&gt;&gt; list.__class__&lt;class 'type'&gt;&gt;&gt;&gt; type(list)&lt;class 'type'&gt;&gt;&gt;&gt; [].__class__&lt;class 'list'&gt;&gt;&gt;&gt; type([])&lt;class 'list'&gt;&gt;&gt;&gt; &#123;&#125;.__class__&lt;class 'dict'&gt;&gt;&gt;&gt; type(&#123;&#125;)&lt;class 'dict'&gt;&gt;&gt;&gt; 'python'.__class__&lt;class 'str'&gt;&gt;&gt;&gt; type('python')&lt;class 'str'&gt; 标识先前说过，每个对象都有标识、类型和值。值得注意的是，可能有多个变量引用同一对象，同样地，变量可以引用看起来相似（有相同的类型和值），但拥有截然不同标识的多个对象。当更改对象时（如将某一项添加到列表），这种关于对象标识的概念尤其重要，如在下面的示例中， list_1 和 list_2 变量引用同一个列表对象。正如您在示例中所见， id() 函数给任何给定对象返回唯一的标识符。 1234567891011121314151617181920&gt;&gt;&gt; print(id.__doc__)Return the identity of an object.This is guaranteed to be unique among simultaneously existing objects.(CPython uses the object's memory address.)# list_1和list_2标识不同&gt;&gt;&gt; list_1 = [1, 2, 3]&gt;&gt;&gt; list_2 = [1, 2, 3]&gt;&gt;&gt; id(list_1)1740112651912&gt;&gt;&gt; id(list_2)1740117536520# a和b标识相同&gt;&gt;&gt; a = 1&gt;&gt;&gt; b = 1&gt;&gt;&gt; id(a)1653632016&gt;&gt;&gt; id(b)1653632016 Python中会为每个出现的对象分配内存，哪怕他们的值完全相等（注意是相等不是相同）。 属性对象拥有属性，并且 dir() 函数会返回这些属性的列表。但是，有时我们只想测试一个或多个属性是否存在。 如果对象具有我们正在考虑的属性，那么通常希望只检索该属性。这个任务可以由hasattr()和 getattr() 函数来完成。 123456789101112131415161718192021222324252627&gt;&gt;&gt; print(hasattr.__doc__)#判断一个对象里面是否有name属性或者name方法，返回BOOL值，有name特性返回True， 否则返回False。需要注意的是name要用括号括起来Return whether the object has an attribute with the given name.This is done by calling getattr(obj, name) and catching AttributeError.&gt;&gt;&gt; print(getattr.__doc__)# 获取对象object的属性或者方法，如果存在打印出来，如果不存在，打印出默认值，默认值可选。# 需要注意的是，如果是返回的对象的方法，返回的是方法的内存地址，如果需要运行这个方法，可以在后面添加一对括号。getattr(object, name[, default]) -&gt; valueGet a named attribute from an object; getattr(x, 'y') is equivalent to x.y.When a default argument is given, it is returned when the attribute doesn'texist; without it, an exception is raised in that case.&gt;&gt;&gt; hasattr(list, '__add__')True&gt;&gt;&gt; hasattr(dict, '__add__')False&gt;&gt;&gt; list_1 = [1, 3, 2]&gt;&gt;&gt; getattr(list_1, 'sort')&lt;built-in method sort of list object at 0x0000019526CAEAC8&gt;&gt;&gt;&gt; getattr(list_1, 'sort')()&gt;&gt;&gt; list_1[1, 2, 3] 此外还有setattr——为对象添加变量或方法 、delattr——删除对象中的变量（不能用于删除方法）。 可调用Python数据类型文档列出了7种可调用对象。 用户定义的函数 使用def语句或lambda表达式创建。 内置函数 使用C语言（CPython）实现的函数，如len或time.strftime。 内置方法 使用C语言实现的方法，如dict.get。 方法 在类的定义体中定义的函数 类 调用类时会运行类的__new__方法创建一个实例，然后运行__init__方法，初始化实例，最后把实例返回给对方。 类的实例 如果类定义了__call__方法，那么它的实例可以作为函数调用 生成器函数 使用yield关键字的函数或方法。调用生成器函数返回的是生成器对象。 Python中有各种各样可调用类型，因此判断对象能否调用，最安全的方法是使用内置的callable()函数： 12345678910&gt;&gt;&gt; print(callable.__doc__)Return whether the object is callable (i.e., some kind of function).Note that classes are callable, as are instances of classes with a__call__() method.&gt;&gt;&gt; abs, str, 13(&lt;built-in function abs&gt;, &lt;class 'str'&gt;, 13)&gt;&gt;&gt; [callable(obj) for obj in (abs, str, 13)][True, True, False] 实例在 type() 函数提供对象的类型时，还可以使用 isinstance() 函数测试对象，以确定它是否是某个特定类型或定制类的实例： 1234567891011121314151617&gt;&gt;&gt; print(isinstance.__doc__)Return whether an object is an instance of a class or of a subclass thereof.A tuple, as in ``isinstance(x, (A, B, ...))``, may be given as the target tocheck against. This is equivalent to ``isinstance(x, A) or isinstance(x, B)or ...`` etc.&gt;&gt;&gt; isinstance(2, int)True&gt;&gt;&gt; isinstance(2, str)False&gt;&gt;&gt; isinstance([1, 2, 3], list)True&gt;&gt;&gt; isinstance(&#123;1, 2, 3&#125;, set)True&gt;&gt;&gt; isinstance(&#123;1, 2, 3&#125;, dict)False 子类关于类的问题，有一个“继承”概念，有继承就有父子问题，这是在现实生活中很正常的，在编程语言中也是如此。 在类这一级别，可以根据一个类来定义另一个类，同样地，这个新类会按照层次化的方式继承属性。Python 甚至支持多重继承，多重继承意味着可以用多个父类来定义一个类，这个新类继承了多个父类。 issubclass() 函数使我们可以查看一个类是不是继承了另一个类： 123456789101112131415&gt;&gt;&gt; print(issubclass.__doc__)Return whether 'cls' is a derived from another class or is the same class.A tuple, as in ``issubclass(x, (A, B, ...))``, may be given as the target tocheck against. This is equivalent to ``issubclass(x, A) or issubclass(x, B)or ...`` etc.&gt;&gt;&gt; from abc import ABC, abstractmethod&gt;&gt;&gt; class Test(ABC): ... @abstractmethod ... def test(self): ... """test""" ... &gt;&gt;&gt; issubclass(Test, ABC) True 函数内省 我们使用实例来讲述函数内省的具体作用。 这部分参考与《流畅的Python》第五章。 首先定义一个函数： 1234567891011121314def clip(text:str, max_len:'int &gt; 0'=80) -&gt; str: """在max_len前面或后面的第一个空格处截断文本""" end = None if len(text) &gt; max_len: space_before = text.rfind(' ', 0, max_len) if space_before &gt;= 0: end = space_before else: space_after = text.rfind(' ', max_len) if space_after &gt;= 0: end = space_after if end is None: end = len(text) return text[:end].rstrip() 使用dir()获取函数的属性使用dir函数可以探知clip具有下述属性： 1['__annotations__', '__call__', '__class__', '__closure__', '__code__', '__defaults__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__get__', '__getattribute__', '__globals__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__kwdefaults__', '__le__', '__lt__', '__module__', '__name__', '__ne__', '__new__', '__qualname__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__'] 其中大多数属性是Python对象共有的。我们重点说明函数专有而用户定义的一般对象没有的属性。 计算两个属性集合的差集便能得到函数专有的属性列表： 1234567&gt;&gt;&gt; class C: pass...&gt;&gt;&gt; obj = C()&gt;&gt;&gt; def func(): pass...&gt;&gt;&gt; sorted(set(dir(func)) - set(dir(obj)))['__annotations__', '__call__', '__closure__', '__code__', '__defaults__', '__get__', '__globals__', '__kwdefaults__', '__name__', '__qualname__'] 列出这些属性的简要说明： 名称 类型 说明 __annotations__ dict 参数和返回值的注解 __call__ method-wrapper 实现（）运算符，即可调用对象协议 __closure__ tuple 函数闭包，即自由变量的绑定（通常是None） __code__ code 编译成字节码的函数元数据和函数定义体 __defaults__ tuple 形式参数的默认值 __get__ method-wrapper 实现制度描述符协议 __globals__ dict 函数所在模块中的全局变量 __kwdefaults__ dict 仅限关键字形式参数的默认值 __name__ str 函数名称 __qualname__ str 函数的限定名称，如Random.choice 获取函数注解123&gt;&gt;&gt; from clip import clip&gt;&gt;&gt; clip.__annotations__&#123;'text': &lt;class 'str'&gt;, 'max_len': 'int &gt; 0', 'return': &lt;class 'str'&gt;&#125; 函数声明中的各个参数可以在：之后增加注解表达式。如果参数有默认值，注解放在参数名和=号之间。如果想注解返回值，在）和函数声明末尾的：之间添加-&gt;表达式。这个表达式可以是任何类型。注解中最常用的类型是类（如str或int）和字符串（如’int&gt;0’）。 获取函数文档字符串12&gt;&gt;&gt; clip.__doc__'在max_len前面或后面的第一个空格处截断文本' 获取函数参数信息12345678&gt;&gt;&gt; clip.__defaults__ (80,) &gt;&gt;&gt; clip.__code__ &lt;code object clip at 0x000001ABE1308780, file "C:\Users\Peng.Gao\Desktop\fluency_python\c5\clip.py", line 1&gt; &gt;&gt;&gt; clip.__code__.co_varnames ('text', 'max_len', 'end', 'space_before', 'space_after') &gt;&gt;&gt; clip.__code__.co_argcount 2 可以看出这种组织信息的方式并不是很便利的。 之后再介绍更好的方式inspect模块。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现统计文本当中单词数量]]></title>
    <url>%2F2018%2F06%2F30%2FPython%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E6%96%87%E6%9C%AC%E5%BD%93%E4%B8%AD%E5%8D%95%E8%AF%8D%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[关于用实现统计文本当中单词数量这个功能，代码进行一步一步的升级。 我做个回顾，或许以后还能写出更符合标准的代码。 1 刚看完《python编程：从入门到实践》的时候写的代码学习python的时候在《python编程：从入门到实践》书中第10章中学习了分析文本，当时写出了统计一个单词出现的频率： 1234567891011121314151617181920# 10-10 常见单词def row_count(filename): try: with open(filename) as f_obj: content = f_obj.read() except FileNotFoundError: msg = "The file " + filename + " does not exist." print(msg) else: content = content.replace(',', ' ') content = content.replace('.', ' ') content = content.replace('-', ' ') content = content.strip().lower() words = content.split() # 统计row单词出现在文本中的次数 number = words.count('row') print('row : %d' % number)filename = 'Heart of Darkness.txt'row_count(filename) 运行结果为： 1row : 9 这个代码只是实现一个单词的出现次数的统计。 并且还有一些问题。比如还有[a、(b这样的标点符号出现在单词中。 2 写完一个单词的统计，又扩展了对所有单词都进行统计并排序当时写完课后作业时，想到了能不能对所有单词都进行统计并进行排序呢，于是上网查了一些资料，写出了下面的代码： 123456789101112131415161718192021222324252627282930313233343536373839from operator import itemgetterdef words_list(filename): try: with open(filename) as f_obj: content = f_obj.read() except FileNotFoundError: msg = "The file " + filename + " does not exist." print(msg) else: content = content.replace(',', ' ') content = content.replace('.', ' ') content = content.replace('!', ' ') content = content.replace('-', ' ') content = content.replace('_', ' ') content = content.replace('(', ' ') content = content.replace(')', ' ') content = content.strip() words = [word.lower() for word in content.split()] return wordsdef count_results(filename): words_count = &#123;&#125; words = words_list(filename) words_count = words_count.fromkeys(words) for word in words_count.keys(): number = words.count(word) words_count[word] = number words_count = sorted(words_count.items(), key=itemgetter(1), reverse=True) return words_countif __name__ == '__main__': filename = 'Heart of Darkness.txt' words_count = count_results(filename) for word, word_count in words_count[:10]: print('&#123;0:&lt;10&#125; : &#123;1&#125;'.format(word, word_count)) 运行结果为： 12345678910the : 2440of : 1492a : 1205and : 1045i : 1039to : 967was : 671in : 668he : 563had : 503 还是有问题，还是有标点符号没有彻底清除，类似这种[a]、_a_。 3 学完正则表达式以后使用正则表达式进行分割单词学会使用正则以后，试着用正则来清除标点符号： 1234567891011121314151617181920212223242526272829303132import refrom operator import itemgetterdef words_list(filename): try: with open(filename) as f_obj: content = f_obj.read() except FileNotFoundError: msg = "The file " + filename + " does not exist." print(msg) else: WORD_RE = re.compile(r'\W+') words = WORD_RE.split(content.lower()) return wordsdef count_results(filename): words_count = &#123;&#125; words = words_list(filename) words_count = words_count.fromkeys(words) for word in words_count.keys(): number = words.count(word) words_count[word] = number words_count = sorted(words_count.items(), key=itemgetter(1), reverse=True) return words_countif __name__ == '__main__': filename = 'Heart of Darkness.txt' words_count = count_results(filename) for word, word_count in words_count[:10]: print('&#123;0:&lt;10&#125; : &#123;1&#125;'.format(word, word_count)) 统计结果为： 12345678910the : 2468of : 1496a : 1209i : 1153and : 1062to : 974in : 673was : 672he : 596it : 515 还是有问题，\w+包含[A-Za-z0-9_]，所以包含’_‘的单词也会被统计出来，比如说‘_that_’也会被统计，并且区别于that。 首先想到就是先把下划线(_)替换为空格即可，不过也可以把_that_和that当做是2种单词。 4 还想到了一个不需要count的解法今天看另一本书《流畅的python》，在学习字典和集合的时候想到了另一种解法： 123456789101112131415161718192021222324252627def count_results(filename): try: with open(filename) as f_obj: content = f_obj.read() except FileNotFoundError: msg = "The file " + filename + " does not exist." print(msg) else: WORD_RE = re.compile(r'\w+') words_count = &#123;&#125; for match in WORD_RE.finditer(content.lower()): word = match.group() # occurrences = words_count.get(word, []) # occurrences.append(word) # words_count[word] = occurrences words_count.setdefault(word, []).append(word) words_count = &#123;word:len(value) for word, value in words_count.items()&#125; words_count = sorted(words_count.items(), key=itemgetter(1), reverse=True) return words_countif __name__ == '__main__': filename = 'Heart of Darkness.txt' words_count = count_results(filename) for word, word_count in words_count[:10]: print('&#123;0:&lt;10&#125; : &#123;1&#125;'.format(word, word_count)) 12345678910the : 2468of : 1496a : 1209i : 1153and : 1062to : 974in : 673was : 672he : 596it : 515 这个方法比使用count的方法速度要快上不少。 5 count方法和len方法速度比较12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import refrom operator import itemgetterdef words_list(filename): try: with open(filename) as f_obj: content = f_obj.read() except FileNotFoundError: msg = "The file " + filename + " does not exist." print(msg) else: WORD_RE = re.compile(r'\W+') words = WORD_RE.split(content.lower()) return wordsdef count_results(filename): words_count = &#123;&#125; words = words_list(filename) words_count = words_count.fromkeys(words) for word in words_count.keys(): number = words.count(word) words_count[word] = number words_count = sorted(words_count.items(), key=itemgetter(1), reverse=True) return words_countdef count_words(filename): try: with open(filename) as f_obj: content = f_obj.read() except FileNotFoundError: msg = "The file " + filename + " does not exist." print(msg) else: WORD_RE = re.compile(r'\w+') words_count = &#123;&#125; for match in WORD_RE.finditer(content.lower()): word = match.group() # occurrences = words_count.get(word, []) # occurrences.append(word) # words_count[word] = occurrences words_count.setdefault(word, []).append(word) words_count = &#123;word: len(value) for word, value in words_count.items()&#125; words_count = sorted(words_count.items(), key=itemgetter(1), reverse=True) return words_countif __name__ == '__main__': import timeit def test_count_results(): filename = 'Heart of Darkness.txt' words_count = count_results(filename) return words_count def test_count_words(): filename = 'Heart of Darkness.txt' words_count = count_words(filename) return words_count time_1 = timeit.Timer('test_count_results()', setup="from __main__ import test_count_results") time_2 = timeit.Timer('test_count_words()', setup="from __main__ import test_count_words") print(time_1.timeit(number=10)) print(time_2.timeit(number=10)) 输出结果为： 1254.6624033767616740.5711055088342789 结果发现差距还是挺大的。 说一个我认为的原因： count需要遍历列表，遍历列表是很消耗时间的，时间复杂度为O(n)； 而使用len()方法时，CPython会直接从内存来读取属性值，当然要快很多。 以下摘自《流畅的python》第一章 如何使用特殊方法 首先明确一点，特殊方法的存在是为了被Python解释器调用的，你自己并不需要调用它们。也就是说没有my_object.__len()__这种写法，而应该使用len(my_object)。在执行len(my_object)的时候，如果my_object是一个自定义类的对象，那么Python会自己去调用其中由你实现的__len__方法。 然而如果是Python内置的类型，比如列表（list）、字符串（str）、字节系列（bytearray）等，那么CPython会抄个近路，__len__实际上会直接返回PyVarObject里的ob_size属性。PyVarObject是表示内存中长度可变的内置对象的C语言结构体。直接读取这个值比调用一个方法要快很多。 目前知识掌握的不太多，还不能很肯定。 说不定以后还有其他的改进，可能未完待续。 6 使用计数器（Counter）方法来实现（目前为止个人觉得最佳解法）好吧，今天在学习《流畅的python》时，又发现了目前为止我认为最佳解决方式。 collections.Counter 这个映射类型会给键准备一个整体计数器。 每次更新一个键的时候会增加这个计数器。所以这个类型可以用来给可散列表对象计数，或者是当成多重集合来用——多重集合就是集合里的元素可以出现不止一次。 Counter实现了+和-运算符用来合并记录，还有像most_common([n])这类很有用的方法。most_common([n])会按照次序返回映射里最常见的n个键和他们的计数，详情参阅文档（https://docs.python.org/3/library/collections.html#collections.Counter）。 看一下使用Counter类来实现对单词进行统计的代码： 123456789101112131415161718192021222324252627282930313233import reimport collectionsdef words_list(filename): try: with open(filename) as f_obj: content = f_obj.read() except FileNotFoundError: msg = "The file " + filename + " does not exist." print(msg) else: WORD_RE = re.compile(r'\W+') words = WORD_RE.split(content.lower()) return words def words_counter(filename): try: with open(filename) as f_obj: content = f_obj.read() except FileNotFoundError: msg = "The file " + filename + " does not exist." print(msg) else: words = words_list(filename) words_count = collections.Counter(words) return words_countif __name__ != '__main__': filename = 'Heart of Darkness.txt' words_count = words_counter(filename) # 注意这个显示前10需要使用words_count.most_common(10)方法 for word, word_count in words_count.most_common(10): print('&#123;0:&lt;20&#125; : &#123;1&#125;'.format(word, word_count)) 结果为： 12345678910the : 2468of : 1496a : 1209i : 1153and : 1062to : 974in : 673was : 672he : 596it : 515 连排序（sorted）都省了，理论上应该更快。我们来测试一下速度。 1234567891011121314151617181920212223242526272829if __name__ == '__main__': import timeit def test_count_results(): filename = 'Heart of Darkness.txt' words_count = count_results(filename) return words_count def test_count_words(): filename = 'Heart of Darkness.txt' words_count = count_words(filename) return words_count def test_words_counter(): filename = 'Heart of Darkness.txt' words_count = words_counter(filename) return words_count time_1 = timeit.Timer('test_count_results()', setup="from __main__ import test_count_results") time_2 = timeit.Timer('test_count_words()', setup="from __main__ import test_count_words") time_3 = timeit.Timer('test_words_counter()', setup="from __main__ import test_words_counter") print(time_1.timeit(number=10)) print(time_2.timeit(number=10)) print(time_3.timeit(number=10)) 结果为： 12336.7605531286150150.379986186752539370.2645591842058579 果然速度更快了。 还能未完待续吗？]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记-正则表达式与re模块]]></title>
    <url>%2F2018%2F06%2F28%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1 使用目的 工作中一直在使用Linux，也使用过正则表达式（grep、awk命令），都是现用现查，没有真正去了解它，用完以后就忘。 学习python之后发现使用python处理文本、日志等文件用正则表达式的地方比较多。每次都得浪费挺长时间去设计正则表达式，就是因为没有真正掌握它，以至于用起来没有得心应手的感觉。 我花费一下午加一晚上的时间阅读了一本《正则表达式必知必会》感觉正则表达式不复杂，但是能熟练、准确、高效的使用它并不是一件容易的时间。必须要多使用、多阅读才行。 目前只是属于入门，等以后如果需要学习爬虫的时候应该需要更深入的了解，那时候再去去阅读《精通正则表达式》。 虽说是入门，也想总结一下便以后查阅。 2 正则表达式基础 2.1 正则表达式简单介绍正则表达式并不是Python的一部分。正则表达式是用于处理字符串的强大工具，拥有自己独特的语法以及一个独立的处理引擎，效率上可能不如str自带的方法，但功能十分强大。 得益于这一点，在提供了正则表达式的语言里，正则表达式的语法都是一样的，区别只在于不同的编程语言实现支持的语法数量不同；但不用担心，不被支持的语法通常是不常用的部分。 正则表达式工具 最基础的功能，测试用还行 http://tool.oschina.net/regex/ （目前用过最好的web端，很适合学习的时候使用） http://regex.zjmainstay.cn/ （上个工具的原版） https://regex101.com/ RegexBuddy （客户端，貌似是最全面的，需要收费，没有使用过） 还有很多类似的工具，网上自己搜索就好。 2.2 正则表达式元字符统计先统计一下正则表达式常用的元字符，在举例详细说明。 元字符 说明 一般字符 匹配自身 . 匹配任何一个单个的字符（在绝大多数的正则表达式实现里，只能匹配除换行符以外的任何单个字符） […] 字符集（字符类）。可以是任意字符；可以使用-（连字符）利用集合区间[…]中第一个字符是^表示取反-（连字符）是一个特殊的元字符，作为元字符只能用在[和]之间，在字符集以外的地方-（连字符）只是一个普通字符，只能与-（连字符）本身相匹配，不需要被转义。所有的元字符在字符集中都失去原有的特殊含义，不需要被转义，但转义了也没有坏处。注意[和]也只能匹配一个字符 \ 转义，将特殊字符变为普通字符 元字符（特定的字符类别） 说明 \w 任何一个字母数字或下划线字符等价于[a-zA-Z0-9_] \W 任何一个非字母数字或非下划线字符等价于[^a-zA-Z0-9_] \d 任何一个数字字符等价于[0-9] \D 任何一个非数字字符等价于[^0-9] \s 任何一个空白字符等价于[\f\n\r\t\v ] （注意字符集中有个空格） \S 任何一个非空白字符等价于[^\f\n\r\t\v ] 元字符（数量词） 说明（用在普通字符、元字符、字符集或子表达式之后） *（贪婪型） 前一个字符或字符集合重复出现0次或多次（无限次） +（贪婪型） 前一个字符或字符集合连续出现1次或多次效果等价于{1,} ？（贪婪型） 前一个字符或字符集合出现0次或1次效果等价于{0,1} {}（贪婪型） 设定前一个字符或字符集合的重复次数{m,n}可以为重复匹配次数设定一个区间{m,}表示重复匹配前一个字符重复次数为m至无限次{,n}表示重复匹配前一个字符重复次数为0至n次 *？（非贪婪型） 匹配尽量少的字符，至少0次 +？（非贪婪型） 匹配尽量少的字符，至少一次 ??（非贪婪型） 匹配尽量少的字符，至少0次 {m,n}？（非贪婪型） 匹配尽量少的字符，至少m次 元字符（边界位置） 说明（边界匹配不消耗待匹配字符串中的字符） ^ 字符串开头在多行模式(?m)中匹配每一行的开头 $ 字符串末尾在多行模式(?m)中匹配每一行的末尾 \A 仅匹配字符串开头 \Z 仅匹配字符串末尾 \b 单词边界匹配这样一个位置：位于一个能够用来构成单词的字符（\w）和一个不能用来构成单词的字符（\W）之间 \B 非单词边界的位置[^\b] 元字符（逻辑分组） 说明 \ 代表左右表达式任意匹配一个总是先尝试匹配左边的表达式，一旦成功则跳过匹配右边的表达式 (…) 小括号里包裹指定子表达式（子串），这就是分组。 分组，分组从1开始，从表达式左边开始每遇到一个分组的左括号时编号+1分组表达式被视为一个整体，可以后接数量词。表达式若有丨表示仅在该组中有效 (?P\&lt;name>…) 命名分组可以给分组起一个唯一的名字，然后用这个名字（而不是相对位置）来引用 \&lt;number> 引用编号为\&lt;number>的分组匹配到的字符串 (?P=name) 引用命名为\&lt;name>的分组匹配到的字符串 元字符（特殊构造） 说明（不作为分组） (?:…) （…）不分组版本 (?=…) 向前查找匹配=后面字符的内容非捕获，不消耗字符串内容（通俗讲就是不包含匹配的字符） (?!…) 向前查找不匹配!后面字符的内容非捕获，不消耗字符串内容（通俗讲就是不包含匹配的字符） (?&lt;=…) 向后查找匹配=后面字符的内容非捕获，不消耗字符串内容（通俗讲就是不包含匹配的字符） (?&lt;!…) 向后查找不匹配!后面字符的内容非捕获，不消耗字符串内容（通俗讲就是不包含匹配的字符） (?(1)yes\丨no) 若成功匹配分组1，则匹配竖线前的子表达式，否则匹配后者。 还有一些递归环视等等元字符目前感觉用不上，通常用于很复杂的情况，暂时不统计。 2.3 正则表达式实例例1：使用数量词 RGB值：用一个十六进制数字给出的红、绿、蓝三基色的组合值。 测试文本（粗体字表示需要匹配出来的字符串）： &lt;BODY BGCOLOR=”#336633“ TEXT=”#FFFFFF“ MARGINWIDTH=”0” MARGINHEIGTH=”0” TOPMARGIN=”0” LEFTMARGIN=”0”&gt; 1#[0-9A-Fa-f]&#123;6&#125; Match 1 完整匹配 20-27 `#336633` Match 2 完整匹配 35-42 `#FFFFFF` 例2：使用分组以及条件判断 查找中国固定电话号码 我国的固定电话号码的规律是区号+电话号码： 最开始的位一定是0，表示长途，接着是2位、3位或者组成的区号。 然后是7位或者8位的电话号码，其中首位不为1。 国内习惯的电话格式有： 029 8845 7890 (029)88457890 (029) 88457890 029-8845-7890 029-88457890 020-8845 7890 测试文本（粗体字表示需要匹配出来的字符串）： 022-5731-3255(0701)40566323010-667788990376 622779104356647988(0376-22444567(0378 2234432 1(?m)^(\()?0[1-9]\d&#123;1,2&#125;(?(1)\)|[- ])[2-9]\d&#123;2,3&#125;[-]?\d&#123;4&#125; 解释一下这个正则表达式： (?m) 表示开启多行匹配 ^(\()?0 表示必须以(开头或者0开头，并把(分组，编号为1 (?(1)\)|[- ])表示若成功匹配到分组1(\()，则匹配)，若匹配补刀分组1，则匹配-或者空格。 Match 1 完整匹配 0-13 `022-5731-3255` Match 2 完整匹配 14-28 `(0701)40566323` 分组 1. 14-15 `(` Match 3 完整匹配 29-41 `010-66778899` Match 4 完整匹配 42-54 `0376 6227791` 例3：子表达式的嵌套用法 IPv4地址由4个字节构成，IP地址中的4组数字分别对应着那4个字节。所以IP地址里的每组数字的取值范围也就是单个字节的表示范围，即0~255。 正则表达式不懂计算，只是一种工具，没办法设定取值范围。 一组数字的取值范围需要我们自己来构造： 任何一个1位或2位数字 任何一个以1开头的3位数字 任何一个以2开头、第二位数字在0~4之间的3位数字 任何一个以25开头、第三位数字在0~5之间的3位数字 测试文本： 255.255.255.01.1.1.122.2.222.234192.168.99.101192.168.99.10111124.258.66.88192192.168.99.101 1\b(((\d&#123;1,2&#125;)|(1\d&#123;2&#125;)|(2[0-4]\d)|(25[0-5]))\.)&#123;3&#125;((\d&#123;1,2&#125;)|(1\d&#123;2&#125;)|(2[0-4]\d)|(25[0-5]))\b Match 1 完整匹配 0-13 `255.255.255.0` 分组 1. 8-12 `255.` 分组 2. 8-11 `255` 分组 6. 8-11 `255` 分组 7. 12-13 `0` 分组 8. 12-13 `0` Match 2 完整匹配 14-21 `1.1.1.1` 分组 1. 18-20 `1.` 分组 2. 18-19 `1` 分组 3. 18-19 `1` 分组 7. 20-21 `1` 分组 8. 20-21 `1` Match 3 完整匹配 22-34 `22.2.222.234` 分组 1. 27-31 `222.` 分组 2. 27-30 `222` 分组 3. 25-26 `2` 分组 5. 27-30 `222` 分组 7. 31-34 `234` 分组 10. 31-34 `234` Match 4 完整匹配 35-49 `192.168.99.101` 分组 1. 43-46 `99.` 分组 2. 43-45 `99` 分组 3. 43-45 `99` 分组 4. 39-42 `168` 分组 7. 46-49 `101` 分组 9. 46-49 `101` 所以我们可以把（…）当做子表达式来使用（比如限制|或者跟数量词等），也可以当做分组来使用（比如回溯引用）。 例4：获取匹配与非获取匹配 在正则表达式匹配的过程中，其实存在“消耗字符”的过程，也就是说，一旦一个字符在匹配过程中被检索（消耗）过，后面的匹配就不会再检索这一字符了。 匹配使用的协议 测试文本：1 https://www.baidu.comhttp://www.cnblogs.comftp://ftp.forta.com 我们先看一个普通的（获取匹配，消耗字符串内容） 1.+(:) 这里：分不分组都一样，这里只是清晰的表达获取匹配和非获取匹配 Match 1 完整匹配 0-6 `https:` Match 2 完整匹配 22-27 `http:` Match 3 完整匹配 45-49 `ftp:` 可以看出：也被匹配进去了，我们如果不想匹配：的话就可以使用非获取匹配，不消耗匹配的字符。 1.+(?=:) Match 1 完整匹配 0-5 `https` Match 2 完整匹配 22-26 `http` Match 3 完整匹配 45-48 `ftp` 可以发现匹配的：并没有出现在我们的最终匹配结果中。 同理，(?!…)(?&lt;=…)(?&lt;!…)也是一样的道理。 例5：贪婪型元字符和非贪婪型元字符 贪婪型总是尝试匹配尽可能多的字符；非贪婪型型则相反，总是尝试匹配尽可能少的字符。 贪婪性元字符 非贪婪型元字符 * *? + +? {m,n} {m,n}? 我们看一个例子： 测试文本： &lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt; 1&lt;div&gt;.*&lt;\/div&gt; Match 1 完整匹配 0-34 &lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt; 1&lt;div&gt;.*?&lt;\/div&gt; Match 1 完整匹配 0-16 &lt;div&gt;test1&lt;/div&gt; Match 2 完整匹配 18-34 &lt;div&gt;test2&lt;/div&gt; 如果只匹配一次的话，使用贪婪模式就尽可能多的匹配符合表达式的结果；而使用非贪婪模式匹配符合表达式就立即停止这次匹配，开始下次匹配。 3 Python re模块使用 re 模块使 Python 语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。 3.1 正则表达式修饰符 - 可选标志正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I（IGNORECASE） 使匹配对大小写不敏感 re.L（LOCALE） 做本地化识别（locale-aware）匹配使预定字符类 \w \W \b \B \s \S 取决于当前区域设定 re.M（ MULTILINE ） 多行匹配，改变 ^ 和 $的行为 re.S（DOTALL） 使 . 匹配包括换行在内的所有字符 re.U（ UNICODE ） 根据Unicode字符集解析字符。使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性 re.X（ VERBOSE ） 详细模式，该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 3.2 反斜杠的困扰与大多数编程语言相同，正则表达式里使用\作为转义字符，这就可能造成反斜杠困扰。 假如你需要匹配文本中的字符\，那么使用编程语言表示的正则表达式里将需要4个反斜杠”\\\\“：前两个和后两个分别用于在编程语言里转义成反斜杠，转换成两个反斜杠后再在正则表达式里转义成一个反斜杠。 Python里的原生字符串很好地解决了这个问题，这个例子中的正则表达式可以使用r’\‘表示。同样，匹配一个数字的’\d’可以写成r’\d’。有了原生字符串，你再也不用担心是不是漏写了反斜杠，写出来的表达式也更直观。 3.3 compile编译正则表达式，返回一个正则表达式（ Pattern ） 对象。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高效率。） 语法： compile(pattern,flags=0) pattern - 编译时用的表达式字符串 flags - 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 123456&gt;&gt;&gt; import re&gt;&gt;&gt; data = "Tina is a good girl, she is cool, clever, and so on..."&gt;&gt;&gt; pattern = re.compile(r'\w*oo\w*', re.I)# 查找所有包含oo的单词，findall方法下面会讲到&gt;&gt;&gt; print(pattern.findall(data))['good', 'cool'] 3.4 match从字符串的起始位置匹配pattern，如果pattern结束时仍可匹配则返回一个macth object对象；如果起始位置匹配不成功的话，match()就返回none。 语法： match(pattern, string, flags=0) pattern - 匹配的正则表达式 string - 要匹配的字符串 flags - 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 group(num=0) - 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() - 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 实例： 1234567891011121314151617181920# 起始位置匹配成功，返回一个match object对象&gt;&gt;&gt; print(re.match('www','www.runoob.com')) &lt;_sre.SRE_Match object; span=(0, 3), match='www'&gt; # match object对象使用span函数来返回一个元组包含匹配的位置&gt;&gt;&gt; print(re.match('www','www.runoob.com').span())(0, 3)# match object对象使用group()函数来返回匹配的字符串,下面会详细讲到&gt;&gt;&gt; print(re.match('www','www.runoob.com').group())www# match object对象使用groups()函数来返回以元组形式分组捕获的字符串&gt;&gt;&gt; print(re.match('(www)','www.runoob.com').groups())('www',)# 起始位置匹配不成功，返回None&gt;&gt;&gt; print(re.match('com','www.runoob.com')) None# 由于返回的不是match object对象，所以不能使用match object对象所包含的方法&gt;&gt;&gt; print(re.match('com','www.runoob.com').span())Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; 3.5 fullmatch从字符串的起始位置匹配pattern，如果完全匹配则返回一个macth object对象；如果从起始位置至结束位置不完全匹配的话，fullmatch()就返回none。 语法： fullmatch(pattern, string, flags=0) pattern - 匹配的正则表达式 string - 要匹配的字符串 flags - 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 group(num=0) - 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() - 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 match和fullmatch的区别 match只考虑起始位置匹配成功即可；而fullmatch则是完全匹配即起始位置和结束位置都匹配成功 实例 1234&gt;&gt;&gt; print(re.fullmatch('www','www.baidu.com'))None&gt;&gt;&gt; print(re.fullmatch('www','www'))&lt;_sre.SRE_Match object; span=(0, 3), match='www'&gt; 3.6 search扫描整个字符串，只返回第一个成功匹配的macth object对象，如果字符串没有匹配则返回None。 语法： search(pattern, string, flags=0) pattern - 匹配的正则表达式 string - 要匹配的字符串 flags - 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 match与search的区别 match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None； 而search匹配整个字符串，直到找到一个匹配。 实例： 1234567891011121314151617&gt;&gt;&gt; line = "Cats are smarter than dogs"# 匹配成功，返回一个match object对象&gt;&gt;&gt; print(re.search(r'(.*)[ ]are[ ](\b\w+?\b)', line, re.M|re.I))&lt;_sre.SRE_Match object; span=(0, 16), match='Cats are smarter'&gt;# 以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)&gt;&gt;&gt; print(re.search(r'(.*)[ ]are[ ](\b\w+?\b)', line, re.M|re.I).groups())('Cats', 'smarter')# 我们编写正则表达式定义了组(...)，这时就可以添加编号或者组名（如果使用了命名分组）来返回一个或多个分组捕获的字符串# 编号0代表返回整个匹配的字符串，不填写参数时（group()）返回group(0)&gt;&gt;&gt; print(re.search(r'(.*)[ ]are[ ](\b\w+?\b)', line, re.M|re.I).group())Cats are smarter&gt;&gt;&gt; print(re.search(r'(.*)[ ]are[ ](\b\w+?\b)', line, re.M|re.I).group(1))Cats&gt;&gt;&gt; print(re.search(r'(.*)[ ]are[ ](\b\w+?\b)', line, re.M|re.I).group(2))smarter&gt;&gt;&gt; print(re.search(r'(.*)[ ]are[ ](\b\w+?\b)', line, re.M|re.I).group(1, 2))('Cats', 'smarter') 3.7 match object对象match和search一旦匹配成功，则返回一个match object对象。 match object对象时一次匹配的结果，包含了很多关于此次匹配的信息。可以使用match提供的可读属性或方法来读取这些信息。 属性： string - 匹配时使用的文本 re - 匹配时使用的pattern对象 pos - 文本中正则表达式开始搜索的索引 endpos - 文本中正则表达式结束搜索的索引 lastindex - 最后一个被捕获的分组的编号，如果没有被捕获的分组则返回None lastgroup - 最后一个被捕获的分组的别名，如果这个分组没有别名或者是没有被捕获的分组则返回None 方法： group(1, 2, …) 获得一个或多个分组捕获的字符串，指定多个参数时将以元组形式返回 参数可以使分组编号也可以是别名 编号0代表整个匹配的字符串，不填写参数时，返回group(0) 没有捕获字符串的组返回None，捕获了多次的组返回最后一次捕获的字符串 groups() 以元组形式返回全部分组捕获的字符串。 相当于group(1, 2, 3, …, last) groupdict() 返回以有别名的组的别名为键，以该组捕获的字符串为值的字典 没有别名的组不包含在内 start(n) 返回指定的组捕获的字符串在string中的起始索引 该索引为匹配的字符串的第一个字符的索引 没有参数时，默认为start(0) end(n) 返回指定的组捕获的字符串在string中的结束索引 该索引为匹配的字符串的最后一个字符的索引+1 没有参数时，默认为end(0) span(n) 以元组形式返回匹配的位置 相当于返回（start(n), end(n)） expand(template) 将匹配到的分组代入template中然后返回 template中可以使用\id或\g&lt; id&gt; \g&lt;name&gt;引用分组，但不能使用编号0 \id与\g&lt;id&gt;是等价的；但\10将被认为是第10个分组，如果你想表达\1之后是字符’0’，只能使用\g&lt;1&gt;0 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&gt;&gt;&gt; line = "Cats are smarter than dogs"&gt;&gt;&gt; match_object = re.search(r'(.*)[ ]are[ ](?P&lt;sign&gt;\b\w+?\b)', line, re.M|re.I)# 返回匹配时使用的文本&gt;&gt;&gt; match_object.string'Cats are smarter than dogs'# 返回匹配时使用的pattern对象&gt;&gt;&gt; match_object.rere.compile('(.*)[ ]are[ ](?P&lt;sign&gt;\\b\\w+?\\b)', re.IGNORECASE|re.MULTILINE)# 文本中正则表达式开始搜索的索引&gt;&gt;&gt; match_object.pos0# 文本中正则表达式结束搜索的索引&gt;&gt;&gt; match_object.endpos26# 最后一个分组的编号&gt;&gt;&gt; match_object.lastindex2# 最后一个被捕获的分组的别名&gt;&gt;&gt; match_object.lastgroup'sign'# 以元组形式返回多个分组捕获的字符串&gt;&gt;&gt; match_object.group(1, 2)('Cats', 'smarter')# 返回分组1捕获的字符串&gt;&gt;&gt; match_object.group(1)'Cats'# 返回整个匹配的字符串&gt;&gt;&gt; match_object.group()'Cats are smarter'# 以元组形式返回全部分组捕获的字符串&gt;&gt;&gt; match_object.groups()('Cats', 'smarter')# 返回以有别名的组的别名为键，以该组捕获的字符串为值的字典&gt;&gt;&gt; match_object.groupdict()&#123;'sign': 'smarter'&#125;# 返回分组2捕获的字符串在string中的起始索引&gt;&gt;&gt; match_object.start(2)9# 返回分组2捕获的字符串在string中的结束索引&gt;&gt;&gt; match_object.end(2)16# 以元组形式返回分组2匹配的位置&gt;&gt;&gt; match_object.span(2)(9, 16)# 将分组1、分组&lt;sign&gt;带入r'\g&lt;sign&gt; \1'中返回。（就是把分组1和分组2对调）&gt;&gt;&gt; match_object.expand(r'\g&lt;sign&gt; \1')'smarter Cats' 3.8 findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 语法： findall(pattern, string, flags=0) pattern - 匹配的正则表达式 string - 要匹配的字符串 flags - 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 findall与match、search的区别 match 和 search 是匹配一次 ，findall 匹配所有 实例： 12345# 编译一个非贪婪匹配数字的正则表达式&gt;&gt;&gt; p = re.compile(r'\d+?')# 使用findall()函数将所有匹配的字符串返回到一个列表中&gt;&gt;&gt; print(p.findall('1fwer334nk432j5'))['1', '3', '3', '4', '4', '3', '2', '5'] 3.9 finditer在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 语法： finditer(pattern, string, flags=0) pattern - 匹配的正则表达式 string - 要匹配的字符串 flags - 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 实例： 12345678910&gt;&gt;&gt; iter = re.finditer('\d+', '1fwer334nk432j5') &gt;&gt;&gt; iter &lt;callable_iterator object at 0x00000124117EBE48&gt; &gt;&gt;&gt; for i in iter: ... print(i.group()) ... 1 334 432 5 3.10 sub使用re替换string中每一个匹配的子串后返回替换后的字符串。 语法： sub(pattern, repl, string, count=0, flags=0) pattern - 匹配的正则表达式 repl - 替换的字符串，也可以是一个函数。当repl是一个字符串时，可以使用\id、\g&lt;id&gt;或\g&lt;name&gt;引用分组；当repl是一个函数时，这个函数只接受一个参数（macth object对象），并返回一个字符串用于替换。 string - 要匹配的字符串 count - 指定最多替换次数，默认全部替换 flags - 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 实例： 1234567891011121314151617181920212223242526272829# 当repl是一个字符串时，可以使用\g&lt;id&gt;引用分组&gt;&gt;&gt; phone = '03766227791'&gt;&gt;&gt; print(re.sub(r'(^\d&#123;4&#125;)', r'\g&lt;1&gt;-', phone))0376-6227791&gt;&gt;&gt; print(re.sub(r'(^\d&#123;4&#125;)', r'(\1)', phone))(0376)6227791# 这个例子虽然把dogs和cats互换了位置，但是还有一个问题，就是大小写的问题，我们用函数来处理它&gt;&gt;&gt; line = "Cats are smarter than dogs"&gt;&gt;&gt; p = re.compile(r'(\b\w+\b)(.*)(\b\w+\b)')&gt;&gt;&gt; p.sub(r'\3\2\1', line)'dogs are smarter than Cats'# 当repl是一个函数时，这个函数只接受一个match object对象作为参数，并返回一个字符串用于替换&gt;&gt;&gt; line = "Cats are smarter than dogs"&gt;&gt;&gt; p = re.compile(r'(\b\w+\b)(.*)(\b\w+\b)')&gt;&gt;&gt; def func(m):... return m.group(3).title() + m.group(2) + m.group(1).lower()...&gt;&gt;&gt; p.sub(func, line)'Dogs are smarter than cats'# 也可以用匿名函数&gt;&gt;&gt; p.sub(lambda m:m.group(3).title()+m.group(2)+m.group(1).lower(), line)'Dogs are smarter than cats'&gt;&gt;&gt; s = 'A23G4HFD567'&gt;&gt;&gt; re.sub(r'(?P&lt;value&gt;\d+?)', lambda m:str(int(m.group('value'))*2), s, 3)'A46G8HFD567' 3.11 subn 返回 (sub(repl, string[, count]), 替换次数） 语法： subn(pattern, repl, string, count=0, flags=0) pattern - 匹配的正则表达式 repl - 替换的字符串，也可以是一个函数。当repl是一个字符串时，可以使用\id、\g&lt;id&gt;或\g&lt;name&gt;引用分组；当repl是一个函数时，这个函数只接受一个参数（macth object对象），并返回一个字符串用于替换。 string - 要匹配的字符串 count - 指定最多替换次数，默认全部替换 flags - 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 实例： 123&gt;&gt;&gt; s = 'A23G4HFD567'&gt;&gt;&gt; re.subn(r'(?P&lt;value&gt;\d+?)', lambda m:str(int(m.group('value'))*2), s)('A46G8HFD101214', 6) 3.12 split按照能够匹配的子串将string分割后返回列表。 语法： split(pattern, string, maxsplit=0, flags=0) pattern - 匹配的正则表达式 string - 要匹配的字符串 maxsplit - 指定最大分割次数，默认全部分割 flags - 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等 实例： 12&gt;&gt;&gt; re.split(r'\d', 'one1two2three3four4five5')['one', 'two', 'three', 'four', 'five', ''] 3.13 purge清空缓存中的正则表达式 语法 purge() 实例： 1&gt;&gt;&gt; re.purge()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python模块</tag>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抓包工具-Fiddler的使用（一）]]></title>
    <url>%2F2018%2F06%2F25%2F%E6%8A%93%E5%8C%85%E5%B7%A5%E5%85%B7-Fiddler%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. Fiddler简介 Fiddler是位于客户端和服务器端的HTTP代理。 它能够记录客户端和服务器之间的所有 HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。 也就是说：客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端，基于这个原因，Fiddler支持所有可以设置http代理为127.0.0.1:8888的浏览器和应用程序。 流程如下所示： 2. Fiddler代理配置 2.1. Windows环境浏览器配置2.1.1. IEFiddler作为系统代理，当启动Fidder时，IE的proxy设定会变成127.0.0.1:8888。 修改端口： 如果8888端口已经被占用，可在fiddler中修改端口。 菜单栏 -&gt; Tools -&gt; Options -&gt; Connections -&gt; Fiddler listens on port: [9999] 如果你的浏览器在开启fiddler之后没有设置相应的代理，则fiddler是无法捕获到HTTP请求的。 当你的系统代理发生变化，Fiddler会有如下警告： 此时若想重新设置fiddler代理，只需点击一下黄色区域即可。 2.1.2. ChromeChrome如果没有使用代理插件，则会自动使用ie的代理配置，只需配置IE的代理配置即可。 在chrome配置中打开代理设置会自动弹出ie的代理配置。 Chrom如果使用了代理插件，就需要配置插件或者直接使用系统代理。 有三种方法： 在插件中选择使用系统代理 把代理插件关闭直接使用系统代理 自己在插件中配置代理： 2.1.3. FirefoxFirefox内置的有代理插件，同样有2种方法来配置： 直接使用系统代理 配置代理 2.1.4. 远程主机抓包还有一种情况，就是Fiddler想抓另一台电脑的包，就需要在另一台电脑上配置代理了。 开启远程链接功能：Fiddler菜单栏 -&gt; Tools -&gt; Options -&gt; connections -&gt; 勾选Allow remote computers to connect 在另一台电脑上配置host(Fiddler所在主机):port(Fiddler配置的端口)代理即可。 2.2. iphone抓包设置2.2.1. 配置Fiddler 开启远程链接功能：Fiddler菜单栏 -&gt; Tools -&gt; Options -&gt; connections -&gt; 勾选Allow remote computers to connect 开启捕获https流量：Fiddler菜单栏 -&gt; Tools -&gt; Options -&gt; HTTPS -&gt; 勾选 Capture HTTPSCONNECTs -&gt; 勾选 Decrypt HTTPS traffic -&gt; 选择from remote clients only -&gt; 勾选Ignore server certificate errors(unsafe) 获取Fiddler所在ip地址（Fiddler所在主机和手机链接同一路由）： 2.2.2. Iphone上配置Fiddler为代理设置 -&gt; 无线局域网 -&gt; 配置无线局域网 -&gt; 配置代理 -&gt; 勾选手动 -&gt; 配置服务器（即Fiddler所在主机）和端口号（Fiddler配置的端口号） 此时，Fiddler可以捕获iphone手机上的http协议的访问。 但是，iphone手机无法访问https协议的请求，接下来，我们需要配置描述文件并信任它。 2.2.3. Iphone上安装Fiddler描述文件 打开Safari浏览器，访问代理服务器ip:port。比如http://192.168.99.206:8888。 点击FiddlerRoot Certificate安装描述文件。 删除描述文件： 若想删除描述文件，设置 -&gt; 通用 -&gt; 描述文件 -&gt; 选中要删除的描述文件 -&gt; 移除描述文件 信任证书：设置 -&gt; 通用 -&gt; 关于本机 -&gt; 证书信任设置 -&gt; 开启对Fiddler的证书信任 此时就可以用Fiddler抓取iphone手机上Safari浏览器和APP的http/https协议的数据包了。 关于IOS版本 ios10.3之前版本的Iphone不需要信任证书。 ios10.3之后版本的Iphone需要信任证书。 2.3 Android抓包配置和iphone类似，只是少了一步安装描述文件。 2.3.1. 配置Fiddler参照iphone配置Fiddler 2.3.2 Android代理配置没有安卓机，下了一个模拟器试验，可能步骤有不同。 设置-&gt; WLAN -&gt; 点击已连接的网络 -&gt; 修改网络 -&gt; 勾选显示高级选项 -&gt; 选择代理为手动 -&gt; 手机的IP地址和Fiddler代理的主机ip地址必须在同一网段，模拟器使用桥接模式还需要下载插件，我懒得弄了，上面的配置手机是访问不了Fiddler主机ip的，故无法抓包，只是为了举例用。 此时，就可以用Fiddler抓取Android手机上浏览器和APP的http/https协议的数据包了。 3. Fiddler 界面简介Fiddler主界面的布局如下： 主界面中主要包括四个常用的块： Fiddler的菜单栏，上图绿色部分。 包括捕获http请求，停止捕获请求，保存http请求，载入本地session、设置捕获规则等功能。 Fiddler的工具栏,上图橙色部分。 包括Fiddler针对当前view的操作（暂停，清除session,decode模式、清除缓存等）。 web Session面板，上图红色区域。 主要是Fiddler抓取到的每条http请求（每一条称为一个session）,主要包含了请求的url，协议，状态码，body等信息，详细的字段含义如下图所示： 字段 信息 # HTTP Request的顺序，从1开始，按照页面加载请求的顺序递增 Result HTTP响应的状态码 Protocol 请求使用的协议，如HTTP/HTTPS/FTP Host 请求地址的域名 URL 请求的服务器路径和文件名，也包括GET参数 BODY 请求的大小，以byte为单位 Caching 请求的缓存过期时间或缓存控制header等值 Process 发出此请求的Winodws进程及进程ID（远程设备获取不到） Comments 用户通过脚本或右键菜单给此session增加的备注 Custom 用户可以通过脚本设置的自定义值 详情和数据统计面板，上图黑色区域。 针对每条http请求的具体统计（例如发送/接受字节数，发送/接收时间，还有粗略统计世界各地访问该服务器所花费的时间）和数据包分析。 下一篇在详细介绍Fiddler的常用功能。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>抓包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记-sorted模块]]></title>
    <url>%2F2018%2F06%2F25%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sort%E4%B8%8Esorted%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[sorted(iterable，key=None,reverse=False) keykey指定一个接收一个参数的函数，这个函数用于从每个元素中提取一个用于比较的关键字。默认值为None 。 reverse是一个布尔值。如果设置为True，列表元素将被倒序排列，默认为False。 python3 sorted取消了对cmp的支持。 例1：按照学生的年龄排序123&gt;&gt;&gt; students = [('john', 'A', 15), ('jane', 'B', 12), ('dave','B', 10)]&gt;&gt;&gt; sorted(students,key=lambda x: x[2])[('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)] 例2：正数在前负数在后；正数从小到大；负数从大到小123&gt;&gt;&gt; list_1 = [7, -8, 5, 4, 0, -2, -5]&gt;&gt;&gt; sorted(list_1, key=lambda x:(x&lt;0,abs(x)))[0, 4, 5, 7, -2, -5, -8] 例3：字符串长度排序123&gt;&gt;&gt; list_2 = ['dddd','a','bb','ccc']&gt;&gt;&gt; sorted(list_2, key=len)['a', 'bb', 'ccc', 'dddd'] 例3：小写 &lt; 大写 &lt; 奇数 &lt; 偶数123&gt;&gt;&gt; s = 'A1ab5C3c4D798'&gt;&gt;&gt; "".join(sorted(s, key=lambda x: (x.isdigit(),x.isdigit() and int(x) % 2 == 0,x.isupper(),x)))'abcACD1357948' 讲一下原理： Boolean 的排序会将 False 排在前，True排在后 。 先比较元组的第一个值，FALSE&lt;TRUE，如果相等就比较元组的下一个值，以此类推。 第一步比较：x.isdigit()的作用是把数字放在前边,字母放在后边。 第二步比较：x.isdigit() and int(x) % 2 == 0的作用是保证奇数在前，偶数在后。 第三步比较：x.isupper()的作用是在前面基础上,保证字母小写在前大写在后。 第四步比较：最后的x表示在前面基础上,对所有类别数字或字母排序 。 例4： 根据字符串中的内嵌数字排序1234l = [ 'ch9.txt', 'ch10.txt', 'ch1.txt', 'ch3.txt', 'ch11.txt' ]&gt;&gt;&gt; import re&gt;&gt;&gt; sorted(l, key = lambda x:int(re.match('\D+(\d+)\.txt',x).group(1)))['ch1.txt', 'ch3.txt', 'ch9.txt', 'ch10.txt', 'ch11.txt'] 例5：list里都是正整数，组合出来最大的数字这个在Python2里面用Sorted加cmp就很容易实现，但是在Python3中由于取消了内置对象__cmp__方法，所以sorted函数的传入比较函数的cmp参数也取消了。 我们可以使用cmp_to_key 来解决cmp的问题： 12345&gt;&gt;&gt; from functools import cmp_to_key&gt;&gt;&gt; list_3 = [3, 30, 34, 5, 9]&gt;&gt;&gt; cmp2key = cmp_to_key(lambda x,y: int(y+x)-int(x+y))&gt;&gt;&gt; print( ''.join(sorted(map(str, list_3), key=cmp2key)))9534330 例6：提取字典的某个key值并进行排序12from operator import itemgettersubmission_dicts = sorted(submission_dicts, key=itemgetter(1), reverse=True) 123456789101112131415161718192021222324&gt;&gt;&gt; help(itemgetter)class itemgetter(builtins.object) | itemgetter(item, ...) --&gt; itemgetter object | | Return a callable object that fetches the given item(s) from its operand. | After f = itemgetter(2), the call f(r) returns r[2]. | After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]) | | Methods defined here: | | __call__(self, /, *args, **kwargs) | Call self as a function. | | __getattribute__(self, name, /) | Return getattr(self, name). | | __new__(*args, **kwargs) from builtins.type | Create and return a new object. See help(type) for accurate signature. | | __reduce__(...) | Return state information for pickling | | __repr__(self, /) | Return repr(self). sort用法与sorted相同。 sort对列表进行永久性排序。 sorted对列表进行临时排序，不改变原列表序列。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 技巧：让进程在后台可靠运行的几种方法]]></title>
    <url>%2F2018%2F06%2F21%2FLinux%20%E6%8A%80%E5%B7%A7%EF%BC%9A%E8%AE%A9%E8%BF%9B%E7%A8%8B%E5%9C%A8%E5%90%8E%E5%8F%B0%E5%8F%AF%E9%9D%A0%E8%BF%90%E8%A1%8C%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Linux 技巧：让进程在后台可靠运行的几种方法我们经常会碰到这样的问题，用 telnet/ssh 登录了远程的 Linux 服务器，运行了一些耗时较长的任务， 结果却由于网络的不稳定导致任务中途失败。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰呢？下面举了一些例子， 您可以针对不同的场景选择不同的方式来处理这个问题。 nohup/setsid/&amp;场景：如果只是临时有一个命令需要长时间运行，什么方法能最简便的保证它在后台稳定运行呢？ 解决方法：我们知道，当用户注销（logout）或者网络断开时，终端会收到 HUP（hangup）信号从而关闭其所有子进程。因此，我们的解决办法就有两种途径：要么让进程忽略 HUP 信号，要么让进程运行在新的会话里从而成为不属于此终端的子进程。 hangup 名称的来由： ​ 在 Unix 的早期版本中，每个终端都会通过 modem 和系统通讯。当用户 logout 时，modem 就会挂断（hang up）电话。 同理，当 modem 断开连接时，就会给终端发送 hangup 信号来通知其关闭所有子进程。 1. nohup nohup 无疑是我们首先想到的办法。顾名思义，nohup 的用途就是让提交的命令忽略 hangup 信号。让我们先来看一下 nohup 的帮助信息： 12345678910111213141516NOHUP(1) User Commands NOHUP(1) NAME nohup - run a command immune to hangups, with output to a non-tty SYNOPSIS nohup COMMAND [ARG]... nohup OPTION DESCRIPTION Run COMMAND, ignoring hangup signals. --help display this help and exit --version output version information and exit 可见，nohup 的使用是十分方便的，只需在要处理的命令前加上 nohup 即可，标准输出和标准错误缺省会被重定向到 nohup.out 文件中。一般我们可在结尾加上“&amp;”来将命令同时放入后台运行，也可用&quot;&gt; filename 2&gt;&amp;1&quot;来更改缺省的重定向文件名。 nohup 示例1234567[root@pvcent107 ~]# nohup ping www.ibm.com &amp;[1] 3059nohup: appending output to `nohup.out'[root@pvcent107 ~]# ps -ef |grep 3059root 3059 984 0 21:06 pts/3 00:00:00 ping www.ibm.comroot 3067 984 0 21:06 pts/3 00:00:00 grep 3059[root@pvcent107 ~]# 2. setsid nohup 无疑能通过忽略 HUP 信号来使我们的进程避免中途被中断，但如果我们换个角度思考，如果我们的进程不属于接受 HUP 信号的终端的子进程，那么自然也就不会受到 HUP 信号的影响了。setsid 就能帮助我们做到这一点。让我们先来看一下 setsid 的帮助信息： 12345678910SETSID(8) Linux Programmer’s Manual SETSID(8) NAME setsid - run a program in a new session SYNOPSIS setsid program [ arg ... ] DESCRIPTION setsid runs a program in a new session. 可见 setsid 的使用也是非常方便的，也只需在要处理的命令前加上 setsid 即可。 setsid 示例12345[root@pvcent107 ~]# setsid ping www.ibm.com[root@pvcent107 ~]# ps -ef |grep www.ibm.comroot 31094 1 0 07:28 ? 00:00:00 ping www.ibm.comroot 31102 29217 0 07:29 pts/4 00:00:00 grep www.ibm.com[root@pvcent107 ~]# 值得注意的是，上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。请将此例与nohup 例中的父 ID 做比较。 3. &amp; 这里还有一个关于 subshell 的小技巧。我们知道，将一个或多个命名包含在“()”中就能让这些命令在子 shell 中运行中，从而扩展出很多有趣的功能，我们现在要讨论的就是其中之一。 当我们将”&amp;”也放入“()”内之后，我们就会发现所提交的作业并不在作业列表中，也就是说，是无法通过jobs来查看的。让我们来看看为什么这样就能躲过 HUP 信号的影响吧。 subshell 示例12345root@pvcent107 ~]# (ping www.ibm.com &amp;)[root@pvcent107 ~]# ps -ef |grep www.ibm.comroot 16270 1 0 14:13 pts/4 00:00:00 ping www.ibm.comroot 16278 15362 0 14:13 pts/4 00:00:00 grep www.ibm.com[root@pvcent107 ~]# 从上例中可以看出，新提交的进程的父 ID（PPID）为1（init 进程的 PID），并不是当前终端的进程 ID。因此并不属于当前终端的子进程，从而也就不会受到当前终端的 HUP 信号的影响了。 disown场景：我们已经知道，如果事先在命令前加上 nohup 或者 setsid 就可以避免 HUP 信号的影响。但是如果我们未加任何处理就已经提交了命令，该如何补救才能让它避免 HUP 信号的影响呢？ 解决方法：这时想加 nohup 或者 setsid 已经为时已晚，只能通过作业调度和 disown 来解决这个问题了。让我们来看一下 disown 的帮助信息： 1234567891011disown [-ar] [-h] [jobspec ...] Without options, each jobspec is removed from the table of active jobs. If the -h option is given, each jobspec is not removed from the table, but is marked so that SIGHUP is not sent to the job if the shell receives a SIGHUP. If no jobspec is present, and neither the -a nor the -r option is supplied, the current job is used. If no jobspec is supplied, the -a option means to remove or mark all jobs; the -r option without a jobspec argument restricts operation to running jobs. The return value is 0 unless a jobspec does not specify a valid job. 可以看出，我们可以用如下方式来达成我们的目的： 用disown -h jobspec来使某个作业忽略HUP信号。 用disown -ah来使所有的作业都忽略HUP信号。 用disown -rh来使正在运行的作业忽略HUP信号。 需要注意的是，当使用过 disown 之后，会将把目标作业从作业列表中移除，我们将不能再使用jobs来查看它，但是依然能够用ps -ef查找到它。 但是还有一个问题，这种方法的操作对象是作业，如果我们在运行命令时在结尾加了“&amp;”来使它成为一个作业并在后台运行，那么就万事大吉了，我们可以通过jobs命令来得到所有作业的列表。但是如果并没有把当前命令作为作业来运行，如何才能得到它的作业号呢？答案就是用 CTRL-z（按住Ctrl键的同时按住z键）了！ CTRL-z 的用途就是将当前进程挂起（Suspend），然后我们就可以用jobs命令来查询它的作业号，再用bg jobspec来将它放入后台并继续运行。需要注意的是，如果挂起会影响当前进程的运行结果，请慎用此方法。 灵活运用 CTRL-z在我们的日常工作中，我们可以用 CTRL-z 来将当前进程挂起到后台暂停运行，执行一些别的操作，然后再用 fg 来将挂起的进程重新放回前台（也可用 bg 来将挂起的进程放在后台）继续运行。这样我们就可以在一个终端内灵活切换运行多个任务，这一点在调试代码时尤为有用。因为将代码编辑器挂起到后台再重新放回时，光标定位仍然停留在上次挂起时的位置，避免了重新定位的麻烦。 disown 示例1（如果提交命令时已经用“&amp;”将命令放入后台运行，则可以直接使用“disown”）123456789[root@pvcent107 build]# cp -r testLargeFile largeFile &amp;[1] 4825[root@pvcent107 build]# jobs[1]+ Running cp -i -r testLargeFile largeFile &amp;[root@pvcent107 build]# disown -h %1[root@pvcent107 build]# ps -ef |grep largeFileroot 4825 968 1 09:46 pts/4 00:00:00 cp -i -r testLargeFile largeFileroot 4853 968 0 09:46 pts/4 00:00:00 grep largeFile[root@pvcent107 build]# logout disown 示例2（如果提交命令时未使用“&amp;”将命令放入后台运行，可使用 CTRL-z 和“bg”将其放入后台，再使用“disown”）123456789101112[root@pvcent107 build]# cp -r testLargeFile largeFile2 [1]+ Stopped cp -i -r testLargeFile largeFile2[root@pvcent107 build]# bg %1[1]+ cp -i -r testLargeFile largeFile2 &amp;[root@pvcent107 build]# jobs[1]+ Running cp -i -r testLargeFile largeFile2 &amp;[root@pvcent107 build]# disown -h %1[root@pvcent107 build]# ps -ef |grep largeFile2root 5790 5577 1 10:04 pts/3 00:00:00 cp -i -r testLargeFile largeFile2root 5824 5577 0 10:05 pts/3 00:00:00 grep largeFile2[root@pvcent107 build]# screen场景：我们已经知道了如何让进程免受 HUP 信号的影响，但是如果有大量这种命令需要在稳定的后台里运行，如何避免对每条命令都做这样的操作呢？ 解决方法：此时最方便的方法就是 screen 了。简单的说，screen 提供了 ANSI/VT100 的终端模拟器，使它能够在一个真实终端下运行多个全屏的伪终端。screen 的参数很多，具有很强大的功能，我们在此仅介绍其常用功能以及简要分析一下为什么使用 screen 能够避免 HUP 信号的影响。我们先看一下 screen 的帮助信息： 12345678910111213141516171819SCREEN(1) SCREEN(1) NAME screen - screen manager with VT100/ANSI terminal emulation SYNOPSIS screen [ -options ] [ cmd [ args ] ] screen -r [[pid.]tty[.host]] screen -r sessionowner/[[pid.]tty[.host]] DESCRIPTION Screen is a full-screen window manager that multiplexes a physical terminal between several processes (typically interactive shells). Each virtual terminal provides the functions of a DEC VT100 terminal and, in addition, several control functions from the ISO 6429 (ECMA 48, ANSI X3.64) and ISO 2022 standards (e.g. insert/delete line and support for multiple character sets). There is a scrollback history buffer for each virtual terminal and a copy-and-paste mechanism that allows moving text regions between windows. 使用 screen 很方便，有以下几个常用选项： 用screen -dmS session name来建立一个处于断开模式下的会话（并指定其会话名）。 用screen -list来列出所有会话。 用screen -r session name来重新连接指定会话。 用快捷键CTRL-a d来暂时断开当前会话。 screen 示例1234567[root@pvcent107 ~]# screen -dmS Urumchi[root@pvcent107 ~]# screen -listThere is a screen on: 12842.Urumchi (Detached)1 Socket in /tmp/screens/S-root. [root@pvcent107 ~]# screen -r Urumchi 当我们用“-r”连接到 screen 会话后，我们就可以在这个伪终端里面为所欲为，再也不用担心 HUP 信号会对我们的进程造成影响，也不用给每个命令前都加上“nohup”或者“setsid”了。这是为什么呢？让我来看一下下面两个例子吧。 1. 未使用 screen 时新进程的进程树123456789[root@pvcent107 ~]# ping www.google.com &amp;[1] 9499[root@pvcent107 ~]# pstree -H 9499init─┬─Xvnc ├─acpid ├─atd ├─2*[sendmail] ├─sshd─┬─sshd───bash───pstree │ └─sshd───bash───ping 我们可以看出，未使用 screen 时我们所处的 bash 是 sshd 的子进程，当 ssh 断开连接时，HUP 信号自然会影响到它下面的所有子进程（包括我们新建立的 ping 进程）。 2. 使用了 screen 后新进程的进程树123456789[root@pvcent107 ~]# screen -r Urumchi[root@pvcent107 ~]# ping www.ibm.com &amp;[1] 9488[root@pvcent107 ~]# pstree -H 9488init─┬─Xvnc ├─acpid ├─atd ├─screen───bash───ping ├─2*[sendmail] 而使用了 screen 后就不同了，此时 bash 是 screen 的子进程，而 screen 是 init（PID为1）的子进程。那么当 ssh 断开连接时，HUP 信号自然不会影响到 screen 下面的子进程了。 总结现在几种方法已经介绍完毕，我们可以根据不同的场景来选择不同的方案。nohup/setsid 无疑是临时需要时最方便的方法，disown 能帮助我们来事后补救当前已经在运行了的作业，而 screen 则是在大批量操作时不二的选择了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记-sys模块]]></title>
    <url>%2F2018%2F06%2F21%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sys%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[sys 模块提供了许多函数和变量来处理 Python 运行时环境的不同部分 。 处理命令行参数 在解释器启动后, argv 列表包含了传递给脚本的所有参数, 列表的第一个元素为脚本自身的名称。 使用sys模块获得脚本的参数1234567print "script name is", sys.argv[0] # 使用sys.argv[0]采集脚本名称if len(sys.argv) &gt; 1: print "there are", len(sys.argv)-1, "arguments:" # 使用len(sys.argv)-1采集参数个数-1为减去[0]脚本名称 for arg in sys.argv[1:]: #输出除了[0]外所有参数 print argelse: print "there are no arguments!" 如果是从标准输入读入脚本 (比如 “python &lt; sys-argv-example-1.py”), 脚本的名称将被设置为空串。 如果把脚本作为字符串传递给python (使用 -c 选项), 脚本名会被设置为 “-c”。 处理模块 path 列表是一个由目录名构成的列表, Python 从中查找扩展模块( Python 源模块, 编译模块,或者二进制扩展). 启动 Python 时,这个列表从根据内建规则, PYTHONPATH 环境变量的内容, 以及注册表( Windows 系统)等进行初始化. 由于它只是一个普通的列表, 你可以在程序中对它进行操作。 使用sys模块操作模块搜索路径123456print "path has", len(sys.path), "members"sys.path.insert(0, "samples") #将路径插入到path,[0]中import samplesys.path = [] #删除path中所有路径import random 使用sys模块查找内建模块builtin_module_names 列表包含 Python 解释器中所有内建模块的名称。 123456789101112131415161718def dump(module): print module, "=&gt;", if module in sys.builtin_module_names: #查找内建模块是否存在 print "&lt;BUILTIN&gt;" else: module = _ _import_ _(module) #非内建模块输出模块路径 print module._ _file_ _dump("os")dump("sys")dump("string")dump("strop")dump("zlib")os =&gt; C:\python\lib\os.pycsys =&gt; &lt;BUILTIN&gt;string =&gt; C:\python\lib\string.pycstrop =&gt; &lt;BUILTIN&gt;zlib =&gt; C:\python\zlib.pyd 使用sys模块查找已导入的模块modules 字典包含所有加载的模块. import 语句在从磁盘导入内容之前会先检查这个字典。 Python 在处理你的脚本之前就已经导入了很多模块。 1234print sys.modules.keys()['os.path', 'os', 'exceptions', '_ _main_ _', 'ntpath', 'strop', 'nt','sys', '_ _builtin_ _', 'site', 'signal', 'UserDict', 'string', 'stat'] 使用sys模块获得当前平台sys.platform 返回当前平台 出现如： “win32” “linux2” 等 处理标准输出/输入标准输入和标准错误 (通常缩写为 stdout 和 stderr) 是内建在每一个 UNIX 系统中的管道。 当你 print 某些东西时，结果前往 stdout 管道；当你的程序崩溃并打印出调试信息 (例如 Python 中的 traceback (错误跟踪)) 的时候，信息前往 stderr 管道。 1234567891011121314&gt;&gt;&gt; for i in range(3):... print'Dive in'Dive inDive inDive in&gt;&gt;&gt; import sys&gt;&gt;&gt; for i in range(3):... sys.stdout.write('Dive in')Dive inDive inDive in&gt;&gt;&gt; for i in range(3):... sys.stderr.write('Dive in')Dive inDive inDive in stdout 是一个类文件对象；调用它的 write 函数可以打印出你给定的任何字符串。 实际上，这就是 print 函数真正做的事情；它在你打印的字符串后面加上一个硬回车，然后调用 sys.stdout.write 函数。 在最简单的例子中，stdout 和 stderr 把它们的输出发送到相同的地方 和 stdout 一样，stderr 并不为你添加硬回车；如果需要，要自己加上。 stdout 和 stderr 都是类文件对象，但是它们都是只写的。 它们都没有 read 方法，只有 write 方法。然而，它们仍然是类文件对象，因此你可以将其它任何 (类) 文件对象赋值给它们来重定向其输出。 使用sys重定向输出123456789print 'Dive in' # 标准输出saveout = sys.stdout # 终在重定向前保存stdout，这样的话之后你还可以将其设回正常fsock = open('out.log', 'w') # 打开一个新文件用于写入。如果文件不存在，将会被创建。如果文件存在，将被覆盖。sys.stdout = fsock # 所有后续的输出都会被重定向到刚才打开的新文件上。print 'This message will be logged instead of displayed' # 这样只会将输出结果“打印”到日志文件中；屏幕上不会看到输出sys.stdout = saveout # 在我们将 stdout 搞乱之前，让我们把它设回原来的方式。 fsock.close() # 关闭日志文件。 重定向错误信息 fsock = open(‘error.log’, ‘w’) # 打开你要存储调试信息的日志文件。sys.stderr = fsock # 将新打开的日志文件的文件对象赋值给stderr以重定向标准错误。raise Exception, ‘this error will be logged’ # 引发一个异常,没有在屏幕上打印出任何东西,所有正常的跟踪信息已经写进error.log 还要注意你既没有显式关闭日志文件，也没有将 stderr 设回最初的值。 这样挺好，因为一旦程序崩溃 (由于引发的异常)，Python 将替我们清理并关闭文件 打印到 stderr向标准错误写入错误信息是很常见的，所以有一种较快的语法可以立刻导出信息 。 12345&gt;&gt;&gt; print 'entering function'entering function&gt;&gt;&gt; import sys&gt;&gt;&gt; print &gt;&gt; sys.stderr, 'entering function'entering function print 语句的快捷语法可以用于写入任何打开的文件 (或者是类文件对象)。 在这里，你可以将单个print语句重定向到stderr而且不用影响后面的print语句。 使用sys模块退出程序12import syssys.exit(1) 注意 sys.exit 并不是立即退出. 而是引发一个 SystemExit 异常. 这意味着你可以在主程序中捕获对 sys.exit 的调用。 捕获sys.exit调用 12345678910import sysprint "hello"try: sys.exit(1)except SystemExit: # 捕获退出的异常 pass # 捕获后不做任何操作print "there"hellothere 如果准备在退出前自己清理一些东西(比如删除临时文件), 你可以配置一个 “退出处理函数”(exit handler), 它将在程序退出的时候自动被调用 。 另一种捕获sys.exit调用的方法 12345678910def exitfunc(): print "world"sys.exitfunc = exitfunc # 设置捕获时调用的函数print "hello"sys.exit(1) # 退出自动调用exitfunc()后，程序依然退出了print "there" # 不会被 printhelloworld 总结123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164# sys_demo.py sys模块相关函数# 该模块含有解释器的一些变量，与解释器交互的函数import sysdef sys_demo(): # 默认编码 print(sys.getdefaultencoding()) # Python版本 print(sys.version) # 添加模块路径到搜索路径 sys.path.append('./module') # (函数)打印异常信息 ''' try: 1 / 0 except: types, value, back = sys.exc_info() # 捕获异常 sys.excepthook(types, value, back) # 打印异常 ''' # 输入和输出 # 标准输出 sys.stdout.write("&gt;&gt; ") # 刷新输出(貌似3.6版本无论是Linux还是winodws加不加都一样) sys.stdout.flush() # 标准输入 strs = sys.stdin.readline()[:-1] # 错误输出 sys.stderr.write("输入内容为： &#123;&#125;".format(strs)) sys.stderr.flush()def sys_func(): # 传递给python脚本的命令行参数列表 # =&gt; python p.py -&gt; ['p.py'] / python p.py a 1 -&gt; ['p.py', 'a', '1'] / 程序内执行 -&gt; ['程序本身路径'] # sys.argv[0] 获取脚本名 # sys.argv[1] 获取第一个参数 # ... lists = sys.argv # 默认字符集名称 strs = sys.getdefaultencoding() # 系统文件名字符集名称 strs = sys.getfilesystemencoding() # 返回object的引用计数 num = sys.getrefcount(object) # 已加载的模块，可修改，但不能通过修改返回的字典进行修改 dicts = sys.modules # 模块搜索路径,初始化时使用PYTHONPATH环境变量的值 lists = sys.path # 动态添加模块搜索路径 sys.path.append('./test') # 平台标识符(系统身份进行详细的检查，推荐使用) strs = sys.platform # python解释器版本 strs = sys.version # 监视器C API版本 num = sys.api_version # 线程信息 lists = sys.thread_info # 捕获异常 types, value, back = sys.exc_info() # 打印异常 sys.excepthook(types, value, back) # 引发SystemExit异常退出Python(可以try), 范围[0,127], None==0, "string"==1 # sys.exit([arg]) # 正常退出 sys.exit(0) # 最大递归数(堆栈最大深度) num = sys.getrecursionlimit() # 修改最大递归数 sys.setrecursionlimit(5000) # 获取线程切换间隔 fnum = sys.getswitchinterval() # 设置线程切换间隔, 单位秒 sys.setswitchinterval(0.005) # 解释器的检查间隔 num = sys.getcheckinterval() # 设置解释器检查间隔, 执行(默认)100个虚拟指令执行一次检查, 值为&lt;=0时,检查每个虚拟指令 sys.setcheckinterval(100) # sys.stdin // 标准输入流 strs = sys.stdin.readline()[:-1] # sys.stdout // 标准出入输出 sys.stdout.write("&gt;&gt;") sys.stdout.flush() # sys.stderr // 标注错误流 sys.stderr.write("&gt;&gt;") # 所有模块 (注:非导入模块) lists = sys.builtin_module_names # Python安装路径 path = sys.base_exec_prefix # 同base_exec_prefix path = sys.base_prefix # 同base_exec_prefix path = sys.exec_prefix # 同base_exec_prefix path = sys.prefix # Python解释器的绝对路径 path = sys.executable # 本机字节顺序指示器, big-endian(最高有效字节在第一位)值为'big', little-endian(最低有效字节在第一位)值为'little' strs = ys.byteorder # python版权 strs = sys.copyright # 16进制版本号 num = sys.hexversion # 当前运行的解释器的信息 lists = sys.implementation # 解释器当前分配的内存块的数量 num = sys.getallocatedblocks() # 是否不会尝试导入源模块是写入.pyc文件 (False会写入.pyc文件) boolean = sys.dont_write_bytecode # 返回对象的大小bit, 只计算自身内存消耗, 不计算引用对象的内存消耗, 调用对象的__sizeof__(), default没有获取到默认返回值 # sys.getsizeof(object[, default]) num = sys.getsizeof(object) # 解释器是否正在被关机 boolean = sys.is_finalizing() # 最大整数值(2 ** 31 -1), 与系统有关 num = sys.maxsize # 最大Unicode值的整数 (1114111) num = sys.maxunicode # 解释器主提示符 strs = sys.ps1 # 解释器次提示符 strs = sys.ps2 # 调用函数 sys.call_tracing(func, ("arg",)) # 清除内部类型缓存 sys._clear_type_cache() # 打印CPython内存分配器状态的低级信息 sys._debugmallocstats() # 设置profile函数, 默认None sys.setprofile(profilefunc) # 获取profile函数 sys.getprofile() # 设置跟踪函数, def tracefunc(frame、event 和arg): sys.settrace(tracefunc) # 获取跟踪函数, 默认None sys.gettrace() # 设置包装 def wrapper(coro): sys.set_coroutine_wrapper(wrapper) # 包装, 默认None sys.get_coroutine_wrapper()if __name__ == '__main__': sys_demo() #sys_func()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记-timeit模块]]></title>
    <url>%2F2018%2F06%2F21%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-timeit%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[timeit模块 timeit.timeit(stmt=’pass’, setup=’pass’, timer=\&lt;defaulttimer>, number=1000000) 返回：返回执行stmt这段代码number遍所用的时间，单位为秒，float型参数： stmt：要执行的那段代码setup：执行代码的准备工作,初始化代码或构建环境导入语句,不计入时间，一般是import之类的timer：这个在win32下是time.clock()，linux下是time.time()，默认的，不用管number：要执行stmt多少遍 12345678910111213import timeitprint(timeit.timeit('sum(x)', 'x=(i for i in range(100))'))def test(): L = [i for i in range(100)]if __name__ == '__main__': import timeit print(timeit.timeit('test()', setup="from __main__ import test", number=100000)) 120.101190333638963780.321354159539091 repeat(stmt=’pass’, setup=’pass’, timer=\&lt;defaulttimer>, repeat=3, number=1000000) 这个函数比timeit函数多了一个repeat参数而已，表示重复执行timeit这个过程多少遍，返回一个列表，表示执行每遍的时间 当然，为了方便，python还用了一个Timer类，Timer类里面的函数跟上面介绍的两个函数是一样的。 12345678910111213import timeitprint(timeit.repeat('sum(x)', 'x=(i for i in range(100))'))def test(): L = [i for i in range(100)]if __name__ == '__main__': import timeit print(timeit.repeat('test()', setup="from __main__ import test", repeat=5, number=100000)) 12[0.106236657178438, 0.1073258932847974, 0.10616481121618107][0.29790928249832355, 0.3105618696372121, 0.30556985822396787, 0.30301376705486294, 0.30120607132593435] timeit.default_timer() 默认的计时器 123456789101112131415161718192021import timeit# 计时器1s1 = timeit.default_timer()print(timeit.repeat('sum(x)', 'x=(i for i in range(100))'))def test(): L = [i for i in range(100)]if __name__ == '__main__': import timeit print(timeit.repeat('test()', setup="from __main__ import test", repeat=5, number=100000))# 计时器2s2 = timeit.default_timer()print(s1, s2, s2 - s1) 123[0.10179332653647721, 0.10404193409330395, 0.10724164534096042][0.30232567090443807, 0.30226451630561224, 0.2942087877875549, 0.30265410958904115, 0.29502689091730194]0.0 1.8100781923555895 1.8100781923555895 Timer类，为了方便，python还用了一个Timer类，Timer类里面的函数跟上面介绍的两个函数是一样。 class timeit.Timer(stmt=’pass’, setup=’pass’,timer=\) Timer.timeit(number=1000000) Timer.repeat(repeat=3,number=1000000) 12345678910import timeitdef test(): L = [i for i in range(100)]time_obj = timeit.Timer(stmt="test()", setup="from __main__ import test")print(time_obj.timeit(number=20000))print(time_obj.repeat(repeat=2, number=20000))print(time_obj.repeat(repeat=5, number=20000)) 1230.06169643712451932[0.060732503797572286, 0.06019152080795917][0.05959408741942987, 0.05915531386421796, 0.06217412724262039, 0.06109216126339412, 0.06159337238104362] 命令行调用 python -m timeit [-n N][-r N][-s S][-t][-c][-h][statement…] -n N 执行指定语句的次数-r N 重复测量的次数(默认3次)-s S 指定初始化代码活构建环境的导入语句(默认pass)-t 使用time.time() (不推荐)-c 使用time.clock() (不推荐)-v 打印原始计时结果-h 帮助 123456$ python -m timeit '"-".join(str(n) for n in range(100))'10000 loops, best of 3: 40.3 usec per loop$ python -m timeit '"-".join([str(n) for n in range(100)])'10000 loops, best of 3: 33.4 usec per loop$ python -m timeit '"-".join(map(str, range(100)))'10000 loops, best of 3: 25.2 usec per loop]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记-random模块]]></title>
    <url>%2F2018%2F06%2F21%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-random%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1. random 生成伪随机数 伪随机数是可预测的，严格意义上不具有随机性质，通常用数学公式的方法（比如统计分布，平方取中等）获得 正如数列需要有首项，产生伪随机数需要一个初值用来计算整个序列，这个初值被称为“种子”。种子可以是一个固定的值，也可以是根据当前系统状态确定的值。 2. random方法1. seed()：改变随机数生成器的种子seed12345678910111213141516# seed() 方法改变随机数生成器的种子，可以在调用其他随机模块函数之前调用此函数# seed()是不能直接访问的，需要导入 random 模块，然后通过 random 静态对象调用该方法import randomrandom.seed()print ("使用默认种子生成随机数：", random.random())random.seed(10)print ("使用整数种子生成随机数：", random.random())random.seed('hello')print ("使用字符串种子生成随机数：", random.random())random.seed(10)print(random.random())random.seed('hello')print(random.random()) 执行后结果为： 12345使用默认种子生成随机数： 0.7446141652673619使用整数种子生成随机数： 0.5714025946899135使用字符串种子生成随机数： 0.35377544047307220.57140259468991350.3537754404730722 也就是说，seed( ) 用于指定随机数生成时所用算法开始的整数值，如果使用相同的seed( )值，则每次生成的随即数都相同，如果不设置这个值，则系统根据时间来自己选择这个值，此时每次生成的随机数因时间差异而不同。 2. getrandbits(k)：返回一个具有x位（bit）随机整数12345678910111213141516171819202122#最小值为0，最大值为15&gt;&gt;&gt; random.getrandbits(4)8&gt;&gt;&gt; random.getrandbits(4)14&gt;&gt;&gt; random.getrandbits(4)15&gt;&gt;&gt; random.getrandbits(4)12&gt;&gt;&gt; random.getrandbits(4)10&gt;&gt;&gt; random.getrandbits(4)7#最小值为0，最大值为255random.getrandbits(8)&gt;&gt;&gt; random.getrandbits(8)239&gt;&gt;&gt; random.getrandbits(8)109&gt;&gt;&gt; random.getrandbits(8)41 3. randrange([start],stop,[step])：从指定范围内，按指定基数递增的集合中获取一个随机数123456789&gt;&gt;&gt; random.randrange(100)52&gt;&gt;&gt; random.randrange(100)37&gt;&gt;&gt; random.randrange(1, 100, 2)25&gt;&gt;&gt; random.randrange(1, 100, 2)99 4. randint(a, b)：随机生成a，b之间的整数1234&gt;&gt;&gt; random.randint(10, 15)13&gt;&gt;&gt; random.randint(10, 15)15 5. choice(seq)：从非空序列中随机挑选一个元素123456789&gt;&gt;&gt; random.choice([1, 3, 6, [3, 6]])1&gt;&gt;&gt; random.choice([1, 3, 6, [3, 6]])[3, 6]&gt;&gt;&gt; random.choice('hello, python')'y'&gt;&gt;&gt; random.choice('hello, python')'n' 6. shuffle(seq, [random] )：将序列的所有元素随机排序1234&gt;&gt;&gt; l = list(range(10))&gt;&gt;&gt; random.shuffle(l)&gt;&gt;&gt; l[2, 6, 3, 4, 7, 5, 0, 8, 1, 9] 7. sample(seq, n)：从指定的序列中，选取n个随机且独立的元素组，不改变原序列12345&gt;&gt;&gt; l = list(range(10))&gt;&gt;&gt; l[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&gt;&gt;&gt; random.sample(l, 5)[5, 3, 1, 7, 0] 8. random()：随机生成一个0到1之间的浮点数1234&gt;&gt;&gt; random.random()0.585264330791065&gt;&gt;&gt; random.random()0.4522431095454009 9. uniform(a, b)：随机生成一个a到b之间的浮点数1234&gt;&gt;&gt; random.uniform(1, 2)1.489053942575901&gt;&gt;&gt; random.uniform(1, 2)1.7829116037672397 常见的函数就介绍到这，还有一些以后需要用到在记录。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python由列表组成的列表中注意的问题]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[今天学习python二分查找，遇见了时间复杂度，有点懵，先简单了解一下。 在计算机科学中，算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。 不懂。继续查资料。 时间频度： 一个算法执行所消耗的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道算法花费的时间是多少。 一个算法花费的时间与算法中语句的执行次数成正比，哪个算法中语句执行次数多，它花费的时间就多。 一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。 时间复杂度 n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。因此我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n)) 称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。 注意，时间频度与时间复杂度时不同的，时间频度不同但时间复杂度可能相同。 如：T(n)=n^2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n^2)。 常见的时间复杂度有： 常数阶O(1) &lt; 对数阶O(log2n) &lt; 线性阶O(n) &lt; 线性对数阶O(nlog2n) &lt; 平方阶O(n^2) &lt; 方阶O(n3) &lt; k次方阶O(n^k) &lt; 指数阶O(2^n) &lt; O(n!)&lt;O(n^n) 目前不想了解太深入，目前主要还是以语法学习为主，以后学习算法时再详细了解。 举几个常见的例子： 时间复杂度为O(1)，就是最低的时间复杂度了，也就是耗时/耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时/空间都不变。哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标。 时间复杂度为O(n)，就代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。 12for i in list: print(i) 时间复杂度为O(n^2)，就代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。 123456def bubble_sort(numbers): for i in range(len(numbers) -1): for j in range(len(numbers) - i - 1): if numbers[j] &gt; numbers[j + 1]: numbers[j], numbers[j + 1] = numbers[j + 1], numbers[j] return numbers 时间复杂度为O(logn)，当数据量增大n倍时，耗时量增大logn倍（这里的log是以2为底的，比如，当数据量增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法。 123456789101112def binary_search(data_list, val): low = 0 high = len(data_list) - 1 while low &lt; high: mid = (low + high) // 2 if data_list[mid] == val: return mid elif data_list[mid] &gt; val: high = mid - 1 else: low = mid + 1 return O(nlogn)同理，就是n乘以logn，当数据增大256倍时，耗时增大256*8=2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记-二分查找与bisect模块]]></title>
    <url>%2F2018%2F06%2F20%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%8Ebisect%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[1. 二分查找 Python 的列表（list）内部实现是一个数组，也就是一个线性表。在列表中查找元素可以使用 list.index() 方法，其时间复杂度为O(n)。对于大数据量，则可以用二分查找进行优化。二分查找要求对象必须有序，其基本原理如下： 从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束； 如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。 如果在某一步骤数组为空，则代表找不到。 二分查找也成为折半查找，算法每一次比较都使搜索范围缩小一半， 其时间复杂度为 O(logn)。 我们分别用递归和循环来实现二分查找： 123456789101112131415161718192021222324def binary_search_loop(data_list, val): low = 0 high = len(data_list) - 1 while low &lt; high: mid = (low + high) // 2 if data_list[mid] == val: return mid elif data_list[mid] &gt; val: high = mid - 1 else: low = mid + 1 returndef binary_search_recursion(data_list, val, low, high): if high &lt; low: return mid = (low + high) // 2 if data_list[mid] == val: return mid elif data_list[mid] &lt; val: return binary_search_recursion(data_list, val, mid + 1, high) else: return binary_search_recursion(data_list, val, low, mid - 1) 接着对这两种实现进行一下性能测试： 123456789101112131415161718192021if __name__ == '__main__': import random import timeit data_list = [random.randint(0, 100000) for _ in range(100000)] data_list.sort() def test_recursion(): binary_search_recursion(data_list, 999, 0, len(data_list) - 1) def test_loop(): binary_search(data_list, 999) t1 = timeit.Timer('test_recursion()', setup='from __main__ import test_recursion') t2 = timeit.Timer('test_loop()', setup='from __main__ import test_loop') print("Recursion: ", t1.timeit()) print("Loop: ", t2.timeit()) 执行结果如下： 12Recursion: 5.192518525994553Loop: 3.60416338798188 可以看出循环方式比递归效率高。 2. bisect模块 2.1 用bisect来搜索并插入bisect(haystack, needle)在haystack（干草垛）里搜索needle（针）的位置，该位置满足的条件是，把needle插入这个位置之后，haystack还能保持升序。 也就是说这个函数返回的位置前面的值，都小于或等于needle的值。 其中haystack必须是一个有序的序列。 你可以先用bisect(haystack, needle)查找位置index，再用haystack.inset(index, needle)来插入新值。但你也可以用insort来一步到位，并且后者速度更快一些。 举例： 123456789101112131415161718192021222324252627282930import bisectimport syshaystack = [1, 4, 5, 6, 8, 12, 15, 20, 21, 23, 23, 26, 29, 30]needles = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31]ROW_FMT = '&#123;0:2d&#125; @ &#123;1:2d&#125; &#123;2&#125;&#123;0:&lt;2d&#125;'def demo(bisect_fn): for needle in reversed(needles): # 用特定的bisect函数来计算元素应该出现的位置 position = bisect_fn(haystack, needle) # 利用该位置来算出需要几个分隔符号 offset = position * ' |' # 把元素和其应该出现的位置打印出来 print(ROW_FMT.format(needle, position, offset))if __name__ == '__main__': # 根据命令上最后一个参数来选用bisect函数 if sys.argv[-1] == 'left': bisect_fn = bisect.bisect_left else: bisect_fn = bisect.bisect # 把选定的函数在抬头打印出来 print('DEMO:', bisect_fn.__name__) print('haystack -&gt;', ' '.join('%2d' % n for n in haystack)) demo(bisect_fn) 1234567891011121314C:\Users\Peng.Gao\Desktop\fluency_python\c2&gt;python bisect_demo.pyDEMO: bisecthaystack -&gt; 1 4 5 6 8 12 15 20 21 23 23 26 29 3031 @ 14 | | | | | | | | | | | | | |3130 @ 14 | | | | | | | | | | | | | |3029 @ 13 | | | | | | | | | | | | |2923 @ 11 | | | | | | | | | | |2322 @ 9 | | | | | | | | |2210 @ 5 | | | | |10 8 @ 5 | | | | |8 5 @ 3 | | |5 2 @ 1 |2 1 @ 1 |1 0 @ 0 0 bisect函数其实是bisect_right函数的别名，后者还有个姊妹函数叫bisect_left。 他们的区别在于，bisect_left返回的插入位置是原序列中跟被插入元素相等的元素的位置，也就是新元素会被放置于与它相等的元素的前面，而bisect_right返回的则是跟它相等的元素之后的位置。 这个细微的差别可能对于整数序列来讲没什么用，但是对于那些值相等但是形式不同的数据类型来讲，结果就不一样了。 比如说虽然1 == 1.0的返回值是True，但1和1.0其实是两个不同的元素。 我们试试使用bisect_left来运行上面的模块： 1234567891011121314C:\Users\Peng.Gao\Desktop\fluency_python\c2&gt;python bisect_demo.py leftDEMO: bisect_lefthaystack -&gt; 1 4 5 6 8 12 15 20 21 23 23 26 29 3031 @ 14 | | | | | | | | | | | | | |3130 @ 13 | | | | | | | | | | | | |3029 @ 12 | | | | | | | | | | | |2923 @ 9 | | | | | | | | |2322 @ 9 | | | | | | | | |2210 @ 5 | | | | |10 8 @ 4 | | | |8 5 @ 2 | |5 2 @ 1 |2 1 @ 0 1 0 @ 0 0 对比可以发现，值1、8、23、29和30的插入位置变成了原序列中这些值的前面。 分析完后，改造一下函数，让它直接返回插入后的结果： 1234567891011121314151617181920import bisectimport syshaystack = [1, 4, 5, 6, 8.0, 12, 15, 20, 21, 23, 23, 26, 29, 30]needles = [0, 1, 2, 5, 8, 10, 22, 23, 29, 30, 31]def demo(bisect_fn): for needle in reversed(needles): position = bisect_fn(haystack, needle) haystack.insert(position, needle) return haystackif __name__ == '__main__': if sys.argv[-1] == 'left': bisect_fn = bisect.bisect_left else: bisect_fn = bisect.bisect print(demo(bisect_fn)) 执行： 1234567# 8在8.0后面C:\Users\Peng.Gao\Desktop\fluency_python\c2&gt;python bisect_demo.py[0, 1, 1, 2, 4, 5, 5, 6, 8.0, 8, 10, 12, 15, 20, 21, 22, 23, 23, 23, 26, 29, 29, 30, 30, 31]# 8在8.0前面C:\Users\Peng.Gao\Desktop\fluency_python\c2&gt;python bisect_demo.py left[0, 1, 1, 2, 4, 5, 5, 6, 8, 8.0, 10, 12, 15, 20, 21, 22, 23, 23, 23, 26, 29, 29, 30, 30, 31] bisect可以用来建立一个用数字作为索引的查询表格，比如说把分数和成绩对应起来： 1234567891011import bisectdef grade(score, breakpoints=list(range(60, 100, 10)), grades='FDCBA'): i = bisect.bisect(breakpoints, score) return grades[i]if __name__ == '__main__': r = [grade(score) for score in [22, 33, 66, 88, 50, 70, 90, 100]] print(r) 2.2 用bisect.insort插入新元素排序很耗时，因此在等到一个有序序列之后，我们最好能保持它的有序。 bisect.insort就是为了这个而存在的。 insort(seq, item)把变量item插入到序列seq中，并能保持seq的升序顺序。 123456789101112import bisectimport randomSIZE = 7random.seed(1729)my_list = []for i in range(SIZE): new_item = random.randrange(SIZE*2) bisect.insort(my_list, new_item) print('%2d -&gt;' % new_item, my_list) 输出结果如下： 123456710 -&gt; [10] 0 -&gt; [0, 10] 6 -&gt; [0, 6, 10] 8 -&gt; [0, 6, 8, 10] 7 -&gt; [0, 6, 7, 8, 10] 2 -&gt; [0, 2, 6, 7, 8, 10]10 -&gt; [0, 2, 6, 7, 8, 10, 10] insort和bisect一样也有个变体叫insort_left，这个变体在背后用的是bisect_left。 附上一个insort和sort的执行时间测试： 1234567891011121314151617181920212223242526272829303132333435363738import bisectimport randomimport timeitdef biscet_insort(list_1, size): random.seed(1729) for i in range(size): new_item = random.randrange(size * 2) bisect.insort(list_1, new_item) return list_1def list_sort(list_2, size): random.seed(1729) for i in range(size): new_item = random.randrange(size * 2) list_2.append(new_item) list_2.sort() return list_2if __name__ == '__main__': list_1, list_2 = [], [] size = 1000 def test_insort(): biscet_insort(list_1, size) def test_sort(): list_sort(list_2, size) t_1 = timeit.Timer('test_insort()', setup='from __main__ import test_insort') t_2 = timeit.Timer('test_sort()', setup='from __main__ import test_sort') print(t_1.timeit(number=100)) print(t_2.timeit(number=100)) 执行结果如下： 121.357789898457706685.78586909665677]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python模块</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python由列表组成的列表中注意的问题]]></title>
    <url>%2F2018%2F06%2F20%2FPython%E7%94%B1%E5%88%97%E8%A1%A8%E7%BB%84%E6%88%90%E7%9A%84%E5%88%97%E8%A1%A8%E4%B8%AD%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[有时候我们需要初始化一个嵌套着几个列表的列表。 最好的选择是使用列表推导： 12345&gt;&gt;&gt; board = [['-'] * 3 for i in range(3)][['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]&gt;&gt;&gt; board[1][2] = 'X'&gt;&gt;&gt; board[['-', '-', '-'], ['-', '-', 'X'], ['-', '-', '-']] 还有一种看上去是个有人的捷径，但实际上是错误的： 123456&gt;&gt;&gt; board = [['-'] * 3] * 3&gt;&gt;&gt; board[['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]&gt;&gt;&gt; board[1][2] = 'X'&gt;&gt;&gt; board[['-', '-', 'X'], ['-', '-', 'X'], ['-', '-', 'X']] 错误的地方在于：第二种方法最终生成的列表其实包含3个指向用一个列表的引用。我们不做修改的时候，看起来还好，一旦我们试图修改其中包含的某一个列表中的元素时，就暴露了列表内的3个引用指向同一个对象的事实。 如图： 列表推导生成列表： 使用*便捷生成列表：]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python中__name__ == '__main__'的作用]]></title>
    <url>%2F2018%2F06%2F20%2FPython%E4%B8%AD__name__%20%3D%20__main__%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[原理 学习python的过程中遇见了if __name__ = = ‘__main__’条件判断。 不明白其作用，去网上查了一下。 网上有一句话概括了这段代码的含义： 让你写的脚本模块既可以导入到别的模块中用，另外该模块自己也可执行。 我们怎么去理解它呢？ 其实很简单，我们只需要弄清楚2点： 执行python模块时，也会执行其中所import的模块 __name__是python内置的全局变量，全局变量__name__存放的是模块的名字。 如果当前模块是主模块或者直接被执行时，此时模块的__name__变量就是__main__，如果当前模块被其他模块调用，则当前模块的__name__就是该模块的名字。 我们举个例子来说明： 情况一：直接执行当前模块时 新建一个test_name_1.py模块： 12# test_name_1.pyprint(__name__) 输出为： 1__main__ 继续扩展： 12345678# test_name_1.pydef test(): print('__name__=', __name__) print(__name__ == '__main__')if __name__ == '__main__': print("Test:") test() 执行test_name_1.py时，输出为： 123Test:__name__= __main__True 也就是说 当你直接执行test_name_1.py时，if __name__ == __main__成立，此时就会执行if语句里面的代码。 情况二： 被其他模块导入并执行时 我们新建一个test_name_2.py模块： 1234# test_name_2.pyimport test_name_1 as tn1tn1.test() 输出为： 12__name__= test_name_1False 注意，此时调用test_name_1模块时，__name__就发生了变化，变成了test_name_1的模块名，而不是’__main__了’。 所以执行test_name_2.py时，执行其中import导入的模块test_name_1.py时，if __name__ == __main__不成立，此时就不会执行if语句里面的代码。 应用场景 加上if __name__ == ‘__main__’ 应用于什么场景？ 我们想排查问题的时候通常会在模块下面加入一些我们调试的代码，我之前是这样做的： 12345678# test_name_1.pydef test(): print('__name__=', __name__) print(__name__ == '__main__')print('Test:')test() 直接执行test_name_1.py时，输出结果和加上if __name == ‘__main__’相同： 123Test:__name__= __main__True 但是这样做有个很大的弊端： 当你从另外一个模块导入此模块时，执行另外一个模块时，也会执行被导入的模块。 比如我们新建一个test_name_2.py 12# test_name_2.pyimport test_name_1 as tn1 执行test_name_2.py时，就会出现一些我在test_name_1.py加入的调试代码： 123test:__name__= test_name_1False 此时，如果不想删除调试代码方便以后的调试，就需要把调试代码放在if __name__ == __main__当中了。 通过这个特性可以在if语句里面添加测试代码，方便后续的测试。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python字符串格式化-占位符与format用法]]></title>
    <url>%2F2018%2F06%2F18%2FPython%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96-%E5%8D%A0%E4%BD%8D%E7%AC%A6%E4%B8%8Eformat%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串格式化方法分为两种：占位符（%）和str.format方式。 占位符方式在python2.x中用的比较广泛，随着python3.x的使用越来越广，str.format方式使用的更加广泛。 个人来讲我更喜欢str.format，但是大部分教程还使用%。 1 占位符（%） 格式 描述 %% 百分号标记 %c 字符及ASCII码 %s 字符串（str） %r 字符串（repr） %d 有符号整数（十进制） %u 无符号整数（十进制） %o 无符号整数（八进制） %x 无符号整数（十六进制） %X 无符号整数（十六进制大写字符） %e 浮点数字（科学计数法） %E 浮点数字（科学计数法，用E代替e） %f 浮点数字（用小数点符号） %g 浮点数字（用根据值的大小采用%e或%f） %G 浮点数字（类似于%g） %p 指针（用十六进制打印值的内存地址） %n 存储输出字符的数量放进参数列表的下一个变量中 1234567891011121314151617&gt;&gt;&gt; age = 25&gt;&gt;&gt; print("My age is %d" %age)My age is 25&gt;&gt;&gt; print("My name is %s" %name)My name is gao&gt;&gt;&gt; x, y = 2, 4&gt;&gt;&gt; print('Vector(%r, %r)' % (x, y))Vector(2, 4)&gt;&gt;&gt; print('%6.3f' % 2.3) 2.300&gt;&gt;&gt; print('%.3f' % 2.3)2.300&gt;&gt;&gt; print('%f' % 2.3)2.300000 2 format方法 2.1 映射 位置映射 123&gt;&gt;&gt; name = 'gao'&gt;&gt;&gt; print('&#123;&#125;,&#123;&#125;!'.format('hello', name))hello,gao! 关键字映射 12&gt;&gt;&gt; print('&#123;name&#125; is &#123;age&#125; years old.'.format(age=25, name='gao'))gao is 25 years old. 元素访问 123456&gt;&gt;&gt; metro_areas = ('Tokyo', 'JP', 36.933, (35.689722, 139.691667))&gt;&gt;&gt; '&#123;0[0]&#125; | &#123;0[3][0]&#125; | &#123;0[3][1]&#125;'.format(metro_areas)'Tokyo | 35.689722 | 139.691667'&gt;&gt;&gt; '&#123;1[0]&#125;:&#123;0[1]&#125;'.format((1, 2), [3, 4])'3:2' 2.2 指定格式结合’:’使用 指定精度 f 1234&gt;&gt;&gt; '&#123;:.4f&#125;'.format(40.808611)'40.8086'&gt;&gt;&gt; '&#123;:9.4f&#125;'.format(40.808611)' 40.8086' 指定进制 b、d、o、x、分别表示二进制、十进制、八进制、十六进制 1234567&gt;&gt;&gt; '&#123;:b&#125;'.format(25)'11001'&gt;&gt;&gt; '&#123;:d&#125;'.format(25)'25'&gt;&gt;&gt; '&#123;:x&#125;'.format(25)'19'&gt;&gt;&gt; '&#123;:o&#125;'.format(25) 指定对其方式^、&lt;、&gt;分别表示居中、左对齐、右对齐。后面带宽度，默认用’ ‘填充，可指定填充方式。 12&gt;&gt;&gt; print('&#123;:-&lt;15&#125; | &#123;:*^9&#125; | &#123;:&gt;9&#125;'.format('', 'lat', 'long'))--------------- | ***lat*** | long 注：填充必须和对其方式结合使用 2.3 定义对象属性1234567891011&gt;&gt;&gt; class Person:... def __init__(self, name, age):... self.name = name... self.age = age... def __str__(self):... return '&#123;self.name&#125; is &#123;self.age&#125;'.format(self=self)...&gt;&gt;&gt; Person('gao', 25)&lt;__main__.Person object at 0x000002708A0C24E0&gt;&gt;&gt;&gt; str(Person('gao', 25))'gao is 25']]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记 - 4 API与后台管理]]></title>
    <url>%2F2018%2F06%2F17%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-API%E4%B8%8E%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. API 1.1 初试API现在让我们进入交互式 Python 命令行，尝试一下 Django 为你创建的各种 API。通过以下命令打开 Python 命令行： 1python manage.py shell 我们使用这个命令而不是简单的使用 “Python” 是因为 manage.py 会设置 DJANGO_SETTINGS_MODULE 环境变量，这个变量会让 Django 根据 mysite/settings.py文件来设置 Python 包的导入路径。 1234567891011121314151617181920212223242526272829# 导入我们刚写的模型类&gt;&gt;&gt; from polls.models import Choice, Question# 系统中目前没有问题&gt;&gt;&gt; Question.objects.all()&lt;QuerySet []&gt;# 创建一个问题，就是通过类来创建对象# 如果你想设置成中国时区，在settings.py文件中把USE_TZ设置为False，TIME_ZONE设置为'Asia/Shanghai'&gt;&gt;&gt; from django.utils import timezone&gt;&gt;&gt; q = Question(question_text="What's new?", pub_date=timezone.now())# 将对象保存在数据库中，save()方法用于创建和更新对象。&gt;&gt;&gt; q.save()# 第一次保存对象后，Django会为Question实例创建一个ID&gt;&gt;&gt; q.id1# 我们还可以通过python属性来访问其他的模型字段值&gt;&gt;&gt; q.question_text"What's new?"&gt;&gt;&gt; q.pub_datedatetime.datetime(2018, 6, 11, 14, 33, 13, 469975)# 通过更改属性来更改字段值，并使用save()来更新&gt;&gt;&gt; q.question_text = "What's up?"&gt;&gt;&gt; q.save()&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: Question object (1)&gt;]&gt; 等等。\&lt;Question: Question object (1)> 对于我们了解这个对象的细节没什么帮助。让我们通过编辑 Question 模型的代码（位于 polls/models.py 中）来修复这个问题。给 Question 和 Choice 增加 str() 方法。 __str__方法是对象的字符串表示形式，我们可以使用描述属性来表示它。 12345678910111213# 创建一个问题类型class Question(models.Model): ... def __str__(self): return self.question_text # 创建一个解决方案类型class Choice(models.Model): ... def __str__(self): return self.choice_text 保存文件后再次打开python交互式命令行： 12345678910111213141516171819202122&gt;&gt;&gt; from polls.models import Choice, Question&gt;&gt;&gt; Question.objects.all()&lt;QuerySet [&lt;Question: What's up?&gt;]&gt; # Django提供了由关键字参数来查找数API&gt;&gt;&gt; Question.objects.filter(id=1)&lt;QuerySet [&lt;Question: What's up?&gt;]&gt;&gt;&gt;&gt; Question.objects.filter(question_text__startswith='What')&lt;QuerySet [&lt;Question: What's up?&gt;]&gt;# 获取今年发布的问题&gt;&gt;&gt; Question.objects.filter(question_text__startswith='What')&lt;QuerySet [&lt;Question: What's up?&gt;]&gt; # 当你请求一个不存在的ID时，会引发异常Traceback (most recent call last): ...polls.models.DoesNotExist: Question matching query does not exist.# 通过主键查找是最常见的情况，Django提供了主键精准查找的方法&gt;&gt;&gt; Question.objects.get(pk=1)&lt;Question: What's up?&gt; 我们给这个问题提供几个选项，调用create()来创建一个新的Choice对象。 12345678910111213141516171819202122232425262728# 通过字段标识获取单个对象&gt;&gt;&gt; q = Question.objects.get(pk=1)# 目前这个问题还没有选项&gt;&gt;&gt; q.choice_set.all()&lt;QuerySet []&gt;# 创建3个选项&gt;&gt;&gt; q.choice_set.create(choice_text='Not much', votes=0)&gt;&gt;&gt; q.choice_set.create(choice_text='The sky', votes=0)&gt;&gt;&gt; c = q.choice_set.create(choice_text='Just hacking again', votes=0)# Choice对象有和它相关联的Question对象的访问权限&gt;&gt;&gt; c.question&lt;Question: What's up?&gt;# 反之亦然，Question对象也可以访问Choice对象&gt;&gt;&gt; q.choice_set.all()&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;# 查找今年发布问题的所有选项，使用双下划线来分隔关系。# 我们会重用上面使用的current_year变量&gt;&gt;&gt; Choice.objects.filter(question__pub_date__year=current_year)&lt;QuerySet [&lt;Choice: Not much&gt;, &lt;Choice: The sky&gt;, &lt;Choice: Just hacking again&gt;]&gt;# 使用delete()删除其中一个选项。&gt;&gt;&gt; c = q.choice_set.filter(choice_text__startswith='Just hacking')&gt;&gt;&gt; c.delete() 1.2 数据库API整理1.2.1 创建对象123456789# 方法一&gt;&gt;&gt; Question.objects.create(question_text="What's up?", pub_date=timezone.now())# 方法二&gt;&gt;&gt; q = Question(question_text="What'up？", pub_date=timezone.now())&gt;&gt;&gt; q.save()# 方法三，先尝试获取，不存在就创建（返回True），存在时不创建(返回False)。&gt;&gt;&gt; Question.objects.get_or_create(question_text="What's up?", pub_date=timezone.now()) 当你创建有关联的对象时(ForeignKey、OneToOneField、ManyToManyField），我们需要先获取与之相关联的对象。我们这样来创建： 123456789101112# 方法一：&gt;&gt;&gt; q = Question.objects.get(pk=1)&gt;&gt;&gt; Choice.objects.create(question=q, Choice_text="Not much", votes=0)# 方法二：&gt;&gt;&gt; q = Question.objects.get(pk=1)&gt;&gt;&gt; c = Choice(question=q, Choice_text="Not much", votes=0)&gt;&gt;&gt; c.save()# 方法三：&gt;&gt;&gt; q = Question.objects.get(pk=1)&gt;&gt;&gt; Choice.objects.get_or_create(question=q, Choice_text="Not much", votes=0) Django 提供了一个更快捷的API来创建对象： 1234567# 方法一&gt;&gt;&gt; q = Question.objects.get(pk=1)&gt;&gt;&gt; q.choice_set.create(choice_text='Not much', votes=0)# 方法二,先尝试获取，不存在就创建（返回True），存在时不创建(返回False)。&gt;&gt;&gt; q = Question.objects.get(pk=1)&gt;&gt;&gt; q.choice_set.get_or_create(choice_text='Not much', votes=0 1.2.2 更改对象我们使用save()来保存已经存在于数据库中的对象的更改： 123&gt;&gt;&gt; q = Question.objects.get(pk=1)&gt;&gt;&gt; q.question_text = "What's new?"&gt;&gt;&gt; q.save 使用update()批量更改对象： 12# 将所有2018年6月12号发布的问题描述全部改为"What"&gt;&gt;&gt; Question.objects.filter(pub_date__year=2018, pub_date__month=6, pub_date__day=12).update(question_text='What') 批量更新对象不需要执行save()就已经保存至数据库，需谨慎操作。 1.2.3 获取对象1234567891011121314151617181920# 获取所有对象&gt;&gt;&gt; Question.objects.all()# 获取单个对象，pk代表主键，主键的字段是ID，所以下面2个语句是等价的&gt;&gt;&gt; Question.objects.get(pk=1)&gt;&gt;&gt; Question.objects.get(id=1)# 使用filter过滤器获取特定对象# filter(**kwargs)：返回匹配给定的查找参数的对象# 获取id等于1的问题&gt;&gt;&gt; Question.objects.filter(id=1)# 获取发布时间为2018年的问题&gt;&gt;&gt; Question.objects.filter(pub_date__year=2018)# 使用exclude过滤器获取特定对象# exclude(**kwargs)：返回与给定的查找参数不匹配的对象# 获取id不等于1之外的所有问题&gt;&gt;&gt; Question.objects.exclude(id=1)# 获取除2018年之外所有发布的问题&gt;&gt;&gt; Question.objects.exclude(pub_date__year=2018) 当你获取与其他对象有关联的对象时，我们还可以跨越关系查找。只需使用模型中相关字段的字段名称用双下划线分隔即可： 123456# 获取问题ID为6的所有选项，再次强调pk为主键，id是主键字段&gt;&gt;&gt; Choice.objects.filter(question__id=1)&gt;&gt;&gt; Choice.objects.filter(question__pk=1)# 反向查找，获取选项开头为"not"(不区分大小写)的所有问题&gt;&gt;&gt; Question.objects.filter(choice__choice_text__istartswith='not') 链接过滤器： 12345678# 获取同时满足发布时间为2018、内容开头为“What”并且不是已“?”结尾的的问题&gt;&gt;&gt; Question.objects.filter(... question_text__startswith='What'... ).filter(... pub_date__year=2018... ).exclude(... question_text__endswith='?'... ) QuerySet（查询集）是惰性执行的，创建查询集不会带来任何数据库的访问，直到查询集写完后需要求值时，才会去访问数据库。例如： 12345&gt;&gt;&gt; q = Question.objects.filter(question_text__startswith='What')&gt;&gt;&gt; q.filter(pub_date__year=2018)&gt;&gt;&gt; q.exclude(question_text__endswith='?')# 直到你需要获取值时，才会去访问数据库&gt;&gt;&gt; print(q) 常用筛选条件： 大于、大于等于：__gt ， __gte 小于、小于等于：__lt， __lte 精准匹配：__exact， __iexact 包含：__contains（不忽略大小写）, __icontains（忽略大小写） 以…开头：__startwith， __istartwith（匹配字符加i忽略大小写基本适用，之后不在描述） 以…结尾：__endswith，__iendswith 在…中：__in 在…范围（使用元组）：__range 是否为空值： __isnull=True，__isnull=False 日期类型： 年：__year 月：__month 日：__day 小时:__hour 分钟:__minut 秒：__second 1.2.4 删除对象我们使用delete()来删除对象： 12345678# 删除id等于1的问题&gt;&gt;&gt; Question.bojects.filter(id=1).delete()# 等同于&gt;&gt;&gt; q = Question.bojects.filter(id=1)&gt;&gt;&gt; q.delete()# 删除所有对象&gt;&gt;&gt; Question.objects.all().delete() 1.2.5 排序对象12345# 根据时间排序&gt;&gt;&gt; Question.objects.all().order_by('pub_date')# 参数前面加-号可以实现倒序&gt;&gt;&gt; Question.objects.all().order_by('-pub_date') 1.2.6 使用索引查询集不支持负索引，想获取最后几个值需要通过其他的方法，例如reverse()或者通过参数前面加-号的方式： 123456789101112# 获取所有问题的前5条&gt;&gt;&gt; Question.objects.all()[:5]# 使用负索引会报错&gt;&gt;&gt; Question.objects.all()[-5:]...AssertionError: Negative indexing is not supported.# 获取最后3个值&gt;&gt;&gt; Question.objects.all().order_by('id').reverse()[:3]# 等同于&gt;&gt;&gt; Question.objects.all().order_by('-id')[:3] 1.2.7 去重对象123# 去除重复的对象&gt;&gt;&gt; q = Question.objects.all()&gt;&gt;&gt; q.distinct() 1.2.8 获取元组形式的对象我们使用values_list()来获取元组形式的对象： 1234567891011# 以元组形式获取问题的描述与发布时间&gt;&gt;&gt; Question.objects.values_list('question_text', 'pub_date')&lt;QuerySet [('What', datetime.datetime(2018, 6, 11, 17, 46)), ('What', datetime.datetime(2018, 6, 11, 18, 47))]&gt;# 如果只需要一个字段，可以指定flat=True&gt;&gt;&gt; Question.objects.values_list('pub_date', flat=True)&lt;QuerySet ['What', 'What', 'What', 'What', 'What', 'What', 'What']&gt;# 转化为列表&gt;&gt;&gt; list(Question.objects.values_list('question_text', flat=True))['What', 'What', 'What', 'What', 'What', 'What', 'What'] 1.2.9 获取字典形式的对象我们使用values()来获取字典形式的对象： 1234567# 以字典形式获取问题的描述与发布时间&gt;&gt;&gt; Question.objects.values('question_text', 'pub_date')&lt;QuerySet [&#123;'question_text': 'What', 'pub_date': datetime.datetime(2018, 6, 11, 17, 46)&#125;]&gt;# 转化为列表&gt;&gt;&gt; list(Question.objects.values('question_text', 'pub_date'))[&#123;'question_text': 'What', 'pub_date': datetime.datetime(2018, 6, 11, 17, 46)&#125;] 2. Django管理页面 为你的员工或客户生成一个用户添加，修改和删除内容的后台是一项缺乏创造性和乏味的工作。因此，Django 全自动地根据模型创建后台界面。 Django 产生于一个公众页面和内容发布者页面完全分离的新闻类站点的开发过程中。站点管理人员使用管理系统来添加新闻、事件和体育时讯等，这些添加的内容被显示在公众页面上。Django 通过为站点管理人员创建统一的内容编辑界面解决了这个问题。 管理界面不是为了网站的访问者，而是为管理者准备的。 2.1 创建一个管理员账号123456789python manage.py createsuperuser# 输入管理用户名Username: admin# 输入管理员邮箱，可不填Email address:# 输入管理员密码Password:Password (again): 2.2 启动开发服务器Django 的管理界面默认就是启用的，它是由django.contrib.admin提供的，不需要添加应用。 直接启动开发服务器，看看它是什么样的。 1python manage.py runserver 现在，打开浏览器，转到你本地域名的 “/admin/“ 目录， 比如 “http://127.0.0.1:8000/admin/“ 。你应该会看见管理员登录界面： 如果你想使用中文，将settings.py中LANGUAGE_CODE设置为’zh-hans’。 123456789LANGUAGE_CODE = 'zh-hans'TIME_ZONE = 'Asia/Shanghai'USE_I18N = TrueUSE_L10N = TrueUSE_TZ = False 2.3 进入管理站点页面现在，试着使用你在上一步中创建的超级用户来登录。然后你将会看到 Django 管理页面的索引页： 你将会看到几种可编辑的内容：组和用户。它们是由 django.contrib.auth 提供的，这是 Django 开发的认证框架。 2.4 向管理页面中加入投票应用但是我们的投票应用在哪呢？它没在索引页面里显示。 只需要做一件事：我们得告诉管理页面，问题 Question 对象需要被管理。打开 polls/admin.py 文件，把它编辑成下面这样： 1234567from django.contrib import adminfrom .models import Choice, Question#注册模块应用admin.site.register(Question)admin.site.register(Choice) 现在我们向管理页面注册了问题 Question类和Choice类，接下来在后台管理页面上来添加问题和选项：]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记 - 3 数据库配置与模型]]></title>
    <url>%2F2018%2F06%2F17%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[现在起，我们将建立数据库，并创建你的第一个模型。 1. 数据库配置 现在，打开 mysite/settings.py 。这是个包含了 Django 项目设置的 Python 模块。 通常，这个配置文件使用 SQLite 作为默认数据库。如果你不熟悉数据库，或者只是想尝试下 Django，这是最简单的选择。Python 内置 SQLite，所以你无需安装额外东西来使用它。当你开始一个真正的项目时，你可能更倾向使用一个更具扩展性的数据库，例如 MySQL，避免中途切换数据库这个令人头疼的问题。 如果你想使用其他数据库，你需要安装合适的 database bindings ，然后改变设置文件中 DATABASES &#39;default&#39; 项目中的一些键值： ENGINE – 数据库引擎配置 ，可选值有 ‘django.db.backends.sqlite3’，’django.db.backends.postgresql’，’django.db.backends.mysql’，或 ‘django.db.backends.oracle’。其它 可用后端。 NAME - 数据库的名称。如果使用的是 SQLite，数据库将是你电脑上的一个文件，在这种情况下， NAME 应该是此文件的绝对路径，包括文件名。默认值 os.path.join(BASE_DIR,’db.sqlite3’) 将会把数据库文件储存在项目的根目录。 如果你不使用 SQLite，则必须添加一些额外设置，比如 USER 、 PASSWORD 、 HOST 等等。想了解更多数据库设置方面的内容，请看文档：DATABASES 。 SQLite 以外的其它数据库 如果你使用了 SQLite 以外的数据库，请确认在使用前已经创建了数据库。你可以通过在你的数据库交互式命令行中使用 “CREATE DATABASE database_name;“ 命令来完成这件事。 另外，还要确保该数据库用户中提供 mysite/settings.py 具有 “create database” 权限。这使得自动创建的 test database 能被以后的教程使用。 如果你使用 SQLite，那么你不需要在使用前做任何事——数据库会在需要的时候自动创建。 本次学习中，我们将使用MySQL数据库来完成后续的操作。 1.1 安装MySQL数据库并配置首先在本地安装mysql数据库，本次是在winodws环境下安装的8.0版本。 安装完成后，为使用方便使用我设置了环境变量： MYSQLHOME D:\MySQL\MySQL Server 8.0 并在环境变量path中添加了 %MYSQL_HOME%\bin 前面我们提到，如果使用SQLite以外其他数据库，必须在使用前已经创建了数据库，并具有一定的权限。所以我们需要进入数据库并创建我们使用的数据库及用户，并赋予用户一些权限。 12345mysql -hlocalhost -uroot -p123456create database pydb character set utf8;create user py_user@&apos;%&apos; identified by &apos;123456&apos;;grant all privileges on pydb.* to &apos;py_user&apos;@&apos;%&apos;;flush privileges; 到这，我们mysql数据库环境已经准备完毕。 1.2 安装mysqlclient驱动并配置前面我们还提到，如果你想使用其他数据库，必须安装合适的 database bindings。所以你需要一个DB API Drivers，即数据库接口驱动，常见的有： mysqlclient - 是一个原生驱动。目前支持Python 2.7,3.4+ ，这是官网推荐的驱动。 MySQL Connector/Python - Oracle官网提供的纯驱动程序，它不需要MySQL客户端库或标准库之外的任何Python模块。 mysqldb - 是用于Python 的流行的MySQL数据库服务器的接口，目前支持Python-2.4到2.7 ，并不支持python3.6。 pymysql - 目标是成为MySQLdb的替代品，支持Python 2.7,3.4+ 。 除了DB API Driver之外，Django还需要一个适配器才能从其ORM访问数据库驱动程序。Django为mysqlclient提供了一个适配器，而MySQL Connector / Python包含他自己的适配器。 我们使用官网推荐的驱动mysqlclient。 1pip install mysqlclient 安装完成后，进行配置来链接数据库。打开mysite/mysite/settings.py配置文件，添加数据库连接配置信息： 1234567891011121314151617# 修改DATABASE配置DATABASES = &#123; 'default': &#123; # 数据库连接字符 'ENGINE': 'django.db.backends.mysql', # 数据库名称 'NAME': 'pydb', # 数据库登录用户 'USER': 'py_user', # 数据库登录密码 'PASSWORD': '123456', # 数据库所在主机IP，本地可以为空 'HOST': '', # 数据库连接端口 'PORT': '3306' &#125;&#125; 到这我们项目就可以连接到mysql数据库了。 使用其他的驱动： 1 MySQL Connector/Python 12&gt; pip install mysql-connector-python&gt; 123456789101112131415161718&gt; # 修改DATABASE配置&gt; DATABASES = &#123;&gt; 'default': &#123;&gt; # 数据库连接字符&gt; 'ENGINE': 'mysql.connector.django',&gt; # 数据库名称&gt; 'NAME': 'pydb',&gt; # 数据库登录用户&gt; 'USER': 'py_user',&gt; # 数据库登录密码&gt; 'PASSWORD': '123456',&gt; # 数据库所在主机IP，本地可以为空&gt; 'HOST': '',&gt; # 数据库连接端口&gt; 'PORT': '3306'&gt; &#125;&gt; &#125;&gt; 注意ENGINE发生了改变，因为mysql.connector.django为MySQL自己提供的Django后端模块。 2 pymysql 12&gt; pip install pimysql&gt; 1234567891011121314151617181920212223&gt; # 引入pymysql模块&gt; import pymysql&gt; # 指定按照mysqldb的方式使用&gt; pymysql.install_as_MySQLdb()&gt; &gt; # 修改DATABASE配置&gt; DATABASES = &#123;&gt; 'default': &#123;&gt; # 数据库连接字符&gt; 'ENGINE': 'django.db.backends.mysql',&gt; # 数据库名称&gt; 'NAME': 'pydb',&gt; # 数据库登录用户&gt; 'USER': 'py_user',&gt; # 数据库登录密码&gt; 'PASSWORD': '123456',&gt; # 数据库所在主机IP，本地可以为空&gt; 'HOST': '',&gt; # 数据库连接端口&gt; 'PORT': '3306'&gt; &#125;&gt; &#125;&gt; 2. 创建模型并和数据库交互 2.1 创建模型在 Django 里写一个数据库驱动的 Web 应用的第一步是定义模型 - 也就是数据库结构设计和附加的其它元数据。 设计哲学 模型是真实数据的简单明确的描述。它包含了储存的数据所必要的字段和行为。Django 遵循 DRY Principle 。它的目标是你只需要定义数据模型，然后其它的杂七杂八代码你都不用关心，它们会自动从模型生成。 来介绍一下迁移 - 举个例子，不像 Ruby On Rails，Django 的迁移代码是由你的模型文件自动生成的，它本质上只是个历史记录，Django 可以用它来进行数据库的滚动更新，通过这种方式使其能够和当前的模型匹配。 在这个简单的投票应用中，需要创建两个模型：问题 Question 和选项 Choice。Question模型有两个字段，问题描述和发布时间。Choice 模型有两个字段，选项描述和当前得票数。每个选项属于一个问题。 我们通过类图来表现这两个模型之间的关系： 我们可以这样来解读它们：一个choice必须与一个（1）question相关联，但是question下面可能与多个（0..*）choice关联。也就是说，一个选项必须属于一个问题，没有问题就没有选项，但是一个问题可能有多个选项，也可能没有选项。（多对一关系） 他们是怎么关联的？通过外键来关联，之后我们会详细讲到。 我们要做的就是来创建Django所表示的类。按照下面的例子来编辑 polls/models.py文件： 1234567891011121314151617181920# 引入django.db模块中的models模块from django.db import models# 创建一个问题类型class Question(models.Model): # 初始化问题描述属性，指定为字符串类型，最大长度200个字符 question_text = models.CharField(max_length=200) # 初始化发布时间属性，指定为日期时间类型 pub_date = models.DateTimeField('date published')# 创建一个解决方案类型class Choice(models.Model): # 将解决方案和问题关联起来，通过外键的形式 question = models.ForeignKey(Question, on_delete=models.CASCADE) # 解决方案的描述信息，字符串，最大长度 choice_text = models.CharField(max_length=200) # 解决方案的投票总数，整数类型，默认0 votes = models.IntegerField(default=0) 每个模型都是django.db.models.Model类的子类。每个类将被转换为数据库表，每个模型有一些类变量，它们都表示模型里的一个数据库字段。 每个字段都是 Field 类的实例 - 比如，字符字段被表示为 CharField ，日期时间字段被表示为 DateTimeField 。这将告诉 Django 每个字段要处理的数据类型。 每个 Field 类实例变量的名字（例如 question_text 或 pub_date ）也是字段名，所以最好使用对机器友好的格式。你将会在 Python 代码里使用它们，而数据库会将它们作为列名。 每个 Field 类实例变量的名字（例如 question_text 或 pub_date ）也是字段名，所以最好使用对机器友好的格式。你将会在 Python 代码里使用它们，而数据库会将它们作为列名。 你可以使用可选的选项来为 Field 定义一个人类可读的名字。这个功能在很多 Django 内部组成部分中都被使用了，而且作为文档的一部分。如果某个字段没有提供此名称，Django 将会使用对机器友好的名称，也就是变量名。在上面的例子中，我们只为 Question.pub_date 定义了对人类友好的名字。对于模型内的其它字段，它们的机器友好名也会被作为人类友好名使用。 定义某些 Field 类实例需要参数。例如 CharField 需要一个 max_length 参数。这个参数的用处不止于用来定义数据库结构，也用于验证数据。 Field 也能够接收多个可选参数；在上面的例子中：我们将 votes 的 default 也就是默认值，设为0。 我们使用 ForeignKey 定义了模型之间的关系。question字段是Question模型的ForeignKey，这将告诉 Django，每个 Choice 对象都关联到一个 Question 对象，并在数据库级别创建适当的关系，也就是外键关联。在创建多对一关系时，需要在ForeignKey的第二参数中加入on_delete=models.CASCADE，表示主外关系键中级联删除，也就是说当删除主表的数据时从表中的数据也一并删除。 2.2 激活模型上面的一小段用于创建模型的代码给了 Django 很多信息，通过这些信息，Django 可以： 为这个应用创建数据库 schema（生成 CREATE TABLE 语句）。 创建可以与 Question 和 Choice 对象进行交互的 Python 数据库 API。 但是首先得把 polls 应用安装到我们的项目里。 设计哲学 Django 应用是“可插拔”的。你可以在多个项目中使用同一个应用。除此之外，你还可以发布自己的应用，因为它们并不会被绑定到当前安装的 Django 上。 为了在我们的工程中包含这个应用，我们需要在配置类 INSTALLED_APPS 中添加设置。因为 PollsConfig 类写在文件 polls/apps.py 中，所以它的点式路径是 ‘polls.apps.PollsConfig’。在文件 mysite/settings.py 中 INSTALLED_APPS 子项添加点式路径后，它看起来像这样： 12345678910111213141516INSTALLED_APPS = [ # 投票模块应用,即我们需要添加的应用 'polls.apps.PollsConfig', # 默认提供的后台管理网站 'django.contrib.admin', # 权限认证模块 'django.contrib.auth', # 内容编码框架模块 'django.contrib.contenttypes', # session会话管理框架模块 'django.contrib.sessions', # 消息队列处理模块 'django.contrib.messages', # 项目静态文件管理模块 'django.contrib.staticfiles',] 现在你的 Django 项目会包含 polls 应用。接着运行下面的命令： 1python manage.py makemigrations polls 你将会看到类似于下面这样的输出： 12345Migrations for 'polls': polls/migrations/0001_initial.py: - Create model Choice - Create model Question - Add field question to choice 通过运行 makemigrations 命令，Django 会检测你对模型文件的修改（在这种情况下，你已经取得了新的），并且把修改的部分储存为一次 迁移。 迁移是 Django 对于模型定义（也就是你的数据库结构）的变化的储存形式 - 没那么玄乎，它们其实也只是一些你磁盘上的文件。如果你想的话，你可以阅读一下你模型的迁移数据，它被储存在 polls/migrations/0001_initial.py 里。别担心，你不需要每次都阅读迁移文件，但是它们被设计成人类可读的形式，这是为了便于你手动修改它们。 Django 有一个自动执行数据库迁移并同步管理你的数据库结构的命令 - 这个命令是 migrate，我们马上就会接触它 - 但是首先，让我们看看迁移命令会执行哪些 SQL 语句。sqlmigrate 命令接收一个迁移的名称，然后返回对应的 SQL： 1python manage.py sqlmigrate polls 0001 你将会看到类似下面这样的输出 ： 123456789101112131415BEGIN;---- Create model Choice--CREATE TABLE `polls_choice` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `choice_text` varchar(200) NOT NULL, `votes` integer NOT NULL);---- Create model Question--CREATE TABLE `polls_question` (`id` integer AUTO_INCREMENT NOT NULL PRIMARY KEY, `question_text` varchar(200) NOT NULL, `pub_date` datetime(6) NOT NULL);---- Add field question to choice--ALTER TABLE `polls_choice` ADD COLUMN `question_id` integer NOT NULL;ALTER TABLE `polls_choice` ADD CONSTRAINT `polls_choice_question_id_c5b4b260_fk_polls_question_id` FOREIGN KEY (`question_id`) REFERENCES `polls_question` (`id`);COMMIT; 请注意以下几点： 输出的内容和你使用的数据库有关，上面的输出示例使用的是 MySQL。 数据库的表名是由应用名(polls)和模型名的小写形式( question 和 choice)连接而来（可自定义）。 主键(IDs)会被自动创建（可自定义）。 默认的，Django 会在外键字段名后追加字符串 “_id” 。（可自定义） 外键关系由 FOREIGN KEY 生成。 生成的 SQL 语句是为你所用的数据库定制的，所以那些和数据库有关的字段类型，比如 auto_increment (MySQL)、 serial (PostgreSQL)和 integer primary keyautoincrement (SQLite)，Django 会帮你自动处理。那些和引号相关的事情 - 例如，是使用单引号还是双引号 - 也一样会被自动处理。 这个 sqlmigrate 命令并没有真正在你的数据库中的执行迁移 - 它只是把命令输出到屏幕上，让你看看 Django 认为需要执行哪些 SQL 语句。这在你想看看 Django 到底准备做什么，或者当你是数据库管理员，需要写脚本来批量处理数据库时会很有用。 如果你感兴趣，你也可以试试运行 python manage.py check ;这个命令帮助你检查项目中的问题，并且在检查过程中不会对数据库进行任何操作。 现在，再次运行 migrate 命令，在数据库里创建新定义的模型的数据表： 1python manage.py migrate 123456789101112131415161718Operations to perform: Apply all migrations: admin, auth, contenttypes, polls, sessionsRunning migrations: Applying contenttypes.0001_initial... OK Applying auth.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying auth.0008_alter_user_username_max_length... OK Applying auth.0009_alter_user_last_name_max_length... OK Applying polls.0001_initial... OK Applying sessions.0001_initial... OK 因为是一次执行migrate命令，所以把自带的默认应用也都迁移了。 这个 migrate 命令选中所有还没有执行过的迁移（Django 通过在数据库中创建一个特殊的表 django_migrations 来跟踪执行过哪些迁移）并应用在数据库上 - 也就是将你对模型的更改同步到数据库结构上。 迁移是非常强大的功能，它能让你在开发过程中持续的改变数据库结构而不需要重新删除和创建表 - 它专注于使数据库平滑升级而不会丢失数据。我们会在后面的教程中更加深入的学习这部分内容，现在，你只需要记住，改变模型需要这三步： 编辑 models.py 文件，改变模型。 运行 python manage.py makemigrations 为模型的改变生成迁移文件。 运行 python manage.py migrate 来应用数据库迁移。 数据库迁移被分解成生成和应用两个命令是为了让你能够在代码控制系统上提交迁移数据并使其能在多个应用里使用；这不仅仅会让开发更加简单，也给别的开发者和生产环境中的使用带来方便。]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记 - 2 项目与模块]]></title>
    <url>%2F2018%2F06%2F17%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E9%A1%B9%E7%9B%AE%E4%B8%8E%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[通过这个教程，我们将带着你创建一个基本的投票应用程序。 它将由两部分组成： 一个让人们查看和投票的公共站点。 一个让你能添加、修改和删除投票的管理站点。 1. 项目 1.1 Django创建项目的结构在使用django开始创建并开发项目之前，我们先简单了解一下Django对于项目的管理结构。 Django之所以可以方便快捷的开发大型WEB应用，最大的特点是它面向对象开发的基础上的模块化开发，将项目中需要的各个功能可以封装成或大或小的模块，这些模块在项目中是可插拔时的，非常有利于项目的更新和扩展 。 所以，Django框架在使用时，首先常见一个项目，然后在项目的基础上，创建各个应用的模块，将模块引入到我们的项目中进行使用。 1.2 Django创建项目首先，我们需要确认要开发Django项目的文件夹，并切换到此目录下 1cd vote_poll\ 然后启动一个新项目，执行下面的命令来创建一个新的 Django 项目： 1django-admin.exe startproject mysite 命令行工具django-admin会在安装Django的时候一起自动安装好。 执行了上面的命令以后，系统会为Django项目生成基础文件夹结构。 现在，我们的vote_poll目录结构如下所示： 123456789vote_poll/ &lt;-- 高级别的文件夹 |-- mysite/ &lt;-- Django项目文件夹 | |-- mysite/ &lt;-- 根模块 | | |-- __init__.py | | |-- settings.py | | |-- urls.py | | |-- wsgi.py | +-- manage.py +-- vote_poll_venv/ &lt;-- 虚拟环境文件夹 这些目录和文件的用处是： 最外层的:file:vote_poll/ 根目录只是你项目的容器， Django 不关心它的名字，你可以将它重命名为任何你喜欢的名字。 manage.py : 一个让你用各种方式管理 Django 项目的命令行工具。 里面一层的 mysite/ 目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 mysite.urls)。 __init.py：一个空文件，这个空文件告诉python这个文件夹是一个python包。 settings.py：这个文件包含了所有的项目配置。 urls.py：Django 项目的 URL 声明，就像你网站的“目录”。 这个文件负责映射我们项目中的路由和路径。 wsgi.py：该文件是用于部署的简单网关接口，作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。 1.3 运行及访问Django项目django自带了一个简单的网络服务器。在开发过程中非常方便，所以我们无需安装任何其他软件即可在本地运行项目。我们可以通过执行命令来测试一下它： 1python manage.py runserver 更换端口 默认情况下，runserver 命令会将服务器设置为监听本机内部 IP 的 8000 端口。 如果你想更换服务器的监听端口，请使用命令行参数。举个例子，下面的命令会使服务器监听 8080 端口： 12&gt; $ python manage.py runserver 8080&gt; 如果你想要修改服务器监听的IP，在端口之前输入新的。比如，为了监听所有服务器的公开IP（这你运行 Vagrant 或想要向网络上的其它电脑展示你的成果时很有用），使用： 12&gt; $ python manage.py runserver 0:8000&gt; 会自动重新加载的服务器 runserver 用于开发的服务器在需要的情况下会对每一次的访问请求重新载入一遍 Python 代码。所以你不需要为了让修改的代码生效而频繁的重新启动服务器。然而，一些动作，比如添加新文件，将不会触发自动重新加载，这时你得自己手动重启服务器。 2. 模块应用 2.1 创建模块应用现在你的开发环境——这个“项目” ——已经配置好了，你可以开始干活了。 在 Django 中，每一个应用都是一个 Python 包，并且遵循着相同的约定。Django 自带一个工具，可以帮你生成应用的基础目录结构，这样你就能专心写代码，而不是创建目录了。 项目 VS 应用： 项目和应用有啥区别？应用是一个专门做某件事的网络应用程序——比如博客系统，或者公共记录的数据库，或者简单的投票程序。项目则是一个网站使用的配置和应用的集合。项目可以包含很多个应用。应用可以被很多个项目使用。 你的应用可以存放在任何 Python path中定义的路径。在这个教程中，我们将在你的 manage.py 同级目录下创建投票应用。这样它就可以作为顶级模块导入，而不是 mysite 的子模块。 请确定你现在处于 manage.py 所在的目录下，然后运行这行命令来创建一个应用： 1python manage.py startapp polls 这将会创建一个 polls 目录，它的目录结构大致如下： 123456789polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py views.py 这个目录结构包括了投票应用的全部内容。 2.2 创建模块应用的第一个视图模块中的视图对应的是views.py文件，打开polls/views.py文件，创建如下方法： 1234567# 引入需要的模块from django.http import HttpResponse# 定义一个处理方法def index(request): return HttpResponse("hello, world. you're at the polls index.") 视图创建完成后，如果想看见效果，我们需要一个URL映射到它，这就是我们需要URLconf的原因。 为了创建URLconfg，在polls目录里新建一个urls.py文件。 现在你的应用目录看起来应该是： 12345678910polls/ __init__.py admin.py apps.py migrations/ __init__.py models.py tests.py urls.py views.py 在polls/urls.pu中，输入如下代码： 1234567from django.urls import pathfrom . import viewsurlpatterns = [ path('', views.index, name='index'),] 下一步是要在根URLconf文件中指定我们创建的polls.urls模块，在mysite/urls.py文件的urlpatterns列表里插入一个include(),如下： 12345678from django.contrib import adminfrom django.urls import include, pathurlpatterns = [ path('admin/', admin.site.urls), path('polls/', include('polls.urls'))] 函数 include()允许引用其它 URLconfs。每当 Django 遇到 :func：~django.urls.include 时，它会截断与此项匹配的 URL 的部分，并将剩余的字符串发送到 URLconf 以供进一步处理。 我们设计 include() 的理念是使其可以即插即用。因为投票应用有它自己的 URLconf( polls/urls.py )，他们能够被放在 “/polls/“ ， “/fun_polls/“ ，”/content/polls/“，或者其他任何路径下，这个应用都能够正常工作。 何时使用 include()： 当包括其它 URL 模式时你应该总是使用 include() ， admin.site.urls 是唯一例外。 你现在把 index 视图添加进了 URLconf。可以验证是否正常工作，运行下面的命令: 1python manage.py runserver 用你的浏览器访问 http://localhost:8000/polls/，你应该能够看见 “Hello, world. You’re at the polls index.“ ，这是你在 index视图中定义的。 函数 path() 具有四个参数，两个必须参数：route 和 view，两个可选参数：kwargs 和 name。现在，是时候来研究这些参数的含义了。 path() 参数： route route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。 这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。 path() 参数： view 当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。稍后，我们会给出一个例子。 path() 参数： kwargs 任意个关键字参数可以作为一个字典传递给目标视图函数。本教程中不会使用这一特性。 path() 参数： name 为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。 在上述配置中我们通过urlpatterns来关联映射关系，整体关系如下图所示： 客户端发起请求：http://localhost:8000/polls 项目接收到用户请求，url地址-&gt; polls/ 进入项目的映射文件urls.py中进行正则匹配：url(&#39;polls&#39;, include(&#39;polls/urls&#39;))，开始打开通过include包含的polls.urls子模块映射文件polls/urls.py 进入项目子模块polls的映射文件中进行匹配，由于polls/路径已经匹配通过，开始匹配polls/后面的路径-&gt; 路径为：’ ‘； 进入polls/urls.py中查找对应的路径-&gt;url(&#39;&#39;, view.index, name=&quot;index&quot;) 匹配到views.index，开始打开子模块的views.py视图文件，执行index视图方法 views.py中的视图方法index()返回了一条字符串，打印到我们浏览器的页面上]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django学习笔记 - 1 概述与安装]]></title>
    <url>%2F2018%2F06%2F17%2FDjango%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[python程序web项目开发，是非常重要的一部分，Python为基础的web项目开发的框架有很多，django无疑是最强大web框架之一，也是我们必须掌握的框架之一 。 框架（framework），就是已经包含了项目结构和部分通用功能的自动化处理工具，主要用于进行项目的快捷和高效开发 Django是一个用 Python 编写的 Web 框架。Web 框架是一种软件，基于web框架可以开发动态网站，各种应用程序以及服务。它提供了一系列工具和功能，可以解决许多与Web开发相关的常见问题，比如：安全功能，数据库访问，会话，模板处理，URL路由，国际化，本地化，等等。 Django是用python编写的最流行的web框架之一。它绝对是最完整的，提供了各种各样的开箱即用的功能，比如用于开发和测试的独立Web服务器，缓存，中间件系统，ORM，模板引擎，表单处理，基于Python单元测试的工具接口。 Django还自带内部电池，提供内置应用程序，比如一个认证系统，一个可用于 CRUD(增删改查) 操作并且自动生成页面的后台管理界面，生成订阅文档（RSS/Atom）,站点地图等。甚至在django中内建了一个地理信息系统（GIS）框架。 1. 核心组件 Django被设计的核心组件主要包含： 对象关系映射（ORM）：以python类的形式定义数据模型，和数据库表关联 URL分配：使用正则表达式匹配URL，可以设计任意的URL没有特定限定，非常灵活 模板系统：强大并且可扩展的模板预言，分隔设计、内容和代码，并且可以继承 表单处理：可以方便生成各种表单模型，实现表单的有效性验证 解决和处理性能问题的缓存 2.Django能做什么 Django是一个python语言为基础的web框架 Django可以开发网站应用，如公司门户网站、学校官方网站、新闻动态网站、购物网站等等各种涉及小、中、大型的网站 Django可以用于开发各种B/S结构的系统平台项目，如公司内部数据管理平台、公司工作流程管理平台、内容管理系统平台、OA办公系统平台等等 总之，Diango是用来进行B/S结构的网络软件开发 C/S结构的软件： 主要是指client-server软件，也就是客户端服务器软件，这样的软件在使用的过程中，需要下载软件的安装包，安装到我们的个人PC上，然后打开联网使用，如QQ，DOTA2等等 B/S结构的软件： 主要是指browser-server软件，客户端只需要一个浏览器就可以，通过浏览器访问服务器上的数据，来完成软件的功能，如淘宝、京东类似的网站就是B/S结构的软件，我们在客户端PC上只需要打开浏览器访问指定的URL地址，就可以进行购物等功能的使用了。 3.安装 3.1 安装python3.6.5参考文档：Centos 7 编译安装Python3.6.5环境 ​ windwos环境下安装Python3.6.5环境 我们将使用windows环境下配合IDE来学习。 3.2 安装Virtualenv1pip3 install virtualenv 到目前为止，我们执行的安装都是在操作系统环境下运行的。从现在开始，我们安装的所有东西，包括django本身，都将安装在虚拟环境中。 这样想一下：对于你开始的每个Django项目，你首先会为它创建一个虚拟环境。这就像每个Django项目都有一个沙盒。所以你随意运行，安装软件包，卸载软件包而不会破坏任何东西。 先创建一个vote_poll目录： 12mkdir vote_pollcd vote_poll Cmder软件： 和cmd说拜拜 这个文件夹是级别较高的目录，将存储与我们的Django项目相关的所有文件和东西，包括它的虚拟环境。 所以让我们开始创建我们的第一个虚拟环境并安装django。 在vote_poll文件夹中创建虚拟环境并激活它： 12python -m venv vote_poll_venvvote_poll_venv\Scripts\activate.bat 如果你在命令行前面看到 (vote_poll_venv)，就代表激活成功了，就像这样： 让我们试着了解一下这里发生了什么。我们创建了一个名为venv的特殊文件夹。该文件夹内包含了一个python的副本。在我们激活了venv环境之后，当我们运行Python命令时，它将使用我们存储在venv里面的本地副本，而不是我们之前在操作系统中安装的那个。 另一个重要的事情是，pip程序也已经安装好了，当我们使用它来安装Python的软件包（比如Django）时，它将被安装在venv环境中。 请注意，当我们启用venv时，我们将使用命令python（而不是python3）来调用Python 3.6.2，并且仅使用pip（而不是pip3）来安装软件包。 顺便说一句，要想退出venv环境，运行下面的命令： 1deactivate 3.3 安装Django 2.0.6在虚拟环境中执行一下命令来安装django： 1pip install django 3.4 验证若要验证 Django 是否能被 Python 识别，可以在 shell 中输入 python。 然后在 Python 提示符下（必须在虚拟环境下），尝试导入 Django： 123&gt;&gt;&gt; import django&gt;&gt;&gt; print(django.get_version())2.0.6]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos 7 编译安装Python3.6.5环境]]></title>
    <url>%2F2018%2F06%2F17%2FCentos%207%20%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Python3.6.5%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一：编译安装123456789101112131415161718192021222324252627# 安装依赖包yum -y install gcc zlib zlib-devel sqlite-devel openssl-devel# 下载wget工具yum -y install wget# 下载源码包wget -c https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz# 解压源码包tar zxf Python-3.6.5.tgz# 进入目录cd Python-3.6.5# 添加配置./configure \--prefix=/usr/python3.6 \ # 指定安装目录--with-ssl \ # 开启ssl协议--enable-shared # 启用构建共享python库# 编译安装make &amp;&amp; make install# 备份python2.7软连接mv /usr/bin/python /usr/bin/python.bak# 配置python3软连接，让系统默认使用Python3ln -s /usr/python3.6/bin/python3 /usr/bin/pythonln -s /usr/python3.6/bin/pip3 /usr/bin/pip# yum使用的是python2，替换python3之后导致无法正常工作，因此需要yum继续使用python2sed -i 's/python/python2/g' /usr/bin/yumsed -i 's/python/python2/g' /usr/libexec/urlgrabber-ext-down# 配置python3环境变量sed -i '$a PATH=$PATH:/usr/python/bin/' /etc/profile 注：如果系统提前没有安装openssl-devel，直接编译安装了python3，使用pip安装时会出现报错： pip is configured with locations that require TLS/SSL, however the ssl module in Python is not available. 这时需要安装openssl-devel后重新配置Python3再编译安装才可使用pip安装： 1234yum -y install openssl-develcd Python-3.6.5./configure --prefix=/usr/python --with-sslmake &amp;&amp; make install 安装好python3后，运行出现下面错误： python3: error while loading shared libraries: libpython3.6m.so.1.0: cannot open shared object file: No such file or directory 解决方案：设置环境变量： 1export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/python/lib/ 注：其中/usr/python/为python3安装的目录 二：yum安装1234567# 安装epel源yum -y install epel-release# 安装python3.6yum -y install python36 python36-devel# 安装pipwget --no-check-certificate https://bootstrap.pypa.io/get-pip.pypython get-pip.py]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python学习笔记 - pip用法]]></title>
    <url>%2F2018%2F06%2F15%2FPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-pip%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python学习笔记 - pip用法pip提供的子命令： 子命令 解释说明 install 安装软件包 download 下载软件包 uninstall 卸载软件包 freeze 按照requirements格式输出安装包，可以到其他服务器上执行pip install -r requirements.txt 直接安装软件 list 列出当前系统的安装包 show 查看安装包的信息，包括版本、依赖、许可证、作者、主页等信息 check 检查安装包的依赖是否完整 config 管理本地或全局配置文件 search 查找安装包 wheel 打包软件到whell格式 completion 生成命令补全配置 help 获取pip和子命令的帮助信息 下面以Flask为例，来看一下pip几个常用的子命令 1234567891011121314151617181920212223242526272829303132333435# 查找安装包：pip search flask# 安装特定的安装包版本：pip install flask==0.8# 删除安装包pip uninstall flask# 查看安装包的信息：pip show flask# 检查安装包的依赖是否完整：pip check flask# 查看已安装的安装包列表：pip list# 导出系统已安装的安装包列表到requirements文件pip freeze &gt; requirements.txt# 从requirements文件安装：pip install -r requirements.txt# 查看本地或全局配置：pip config list# 查看、修改、删除本地或全局配置：pip config set 'global.index-url' 'https://pypi.douban.com/simple/'pip config get 'global.index-url' pip config unset 'global.index-url'# 使用pip命令补全：pip completion --bash &gt;&gt; ~/.profilesource ~/.profile 使用豆瓣或阿里云的源加速软件安装123456789101112# 通过pip命令的-i选项指定镜像源即可，如下所示：pip install -i https://pypi.douban.com/simple/ flask# 每次都要指定镜像源的地址比较麻烦，可以修改Pip配置文件，将镜像源写入配置文件中。# 豆瓣源，可以换成其他的源pip config set 'global.index-url' 'https://pypi.douban.com/simple/'# 添加豆瓣源为可信主机，要不然可能报错pip config set 'trusted-host' 'pypi.douban.com'# 取消pip版本检查，排除每次都报最新的pippip config set 'disable-pip-version-check' 'true'# 设置超时时间pip config set 'timeout' '120' 注：pip源配置文件可以放置的位置： /etc/pip.conf ~/.pip/pip.conf ~/.config/pip/pip.conf(使用pip config set命令时会创建在此目录中) 将软件下载到本地部署12345# 下载到本地pip download -d 'pwd' -r requirements.txt # 本地安装pip install --no-index -f file://'pwd' -r requirements.txt ​ ​ ​ ​ ​ ​ ​]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
